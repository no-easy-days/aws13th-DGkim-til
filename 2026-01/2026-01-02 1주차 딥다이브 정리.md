# 딥다이브 주제

“관련 주제 힌트” 및 “조사할 때 신경쓰면 좋은 것” 항목이 있다고해서 저것만 조사하시면 안됩니다!
처음 해보시는 상태이니 “앞으로 이런식으로 주제를 탐구하셔야 합니다”라는 가이드일 뿐이고 이것 이상으로 조사하셔도 됩니다!

## **1. 리스트(List)와 셋(Set)의 속도 차이와 해시 테이블(Hash Table)**

- **관련 주제 힌트:** 자료구조(Data Structure), 시간 복잡도(Time Complexity - Big O), 해시 함수(Hash Function)
- 조사 할 때 신경쓰면 좋은 것
    - 리스트에서 특정 값을 찾는 것(`in` 연산자)과 셋에서 찾는 것의 속도 차이는 왜 발생하는가?
    - Python의 Dictionary와 Set은 내부적으로 어떻게 데이터를 저장하는가? (키워드: Hash Table)
    - 해시 충돌(Hash Collision)이란 무엇이며, Python은 이를 어떻게 해결하는가?
- 제프 의견
    - 리스트와 셋의 문법적 차이는 알지만 **"왜 데이터가 많아질수록 셋(Set)이나 딕셔너리(Dictionary)가 검색 속도에서 월등히 빠른가?"**에 대한 CS적 원리를 정확하게 이해하는게 핵심입니다

## 2. Mutable vs Immutable: Python의 메모리 관리 모델

- **관련 주제 힌트:** 메모리 구조(Stack vs Heap), 포인터(Pointer), 참조(Reference), Call by Value vs Call by Reference
- 조사 할 때 신경쓰면 좋은 것
    - `a = [1, 2, 3]`일 때 `b = a`를 하고 `b`를 수정하면 왜 `a`도 바뀌는가? (Shallow Copy)
    - 반면, `a = 10`일 때 `b = a`를 하고 `b`를 수정해도 왜 `a`는 안 바뀌는가?
    - `id()` 함수를 사용하여 Mutable 객체(List)와 Immutable 객체(Tuple, Int)의 메모리 주소 변화를 추적해 보자.
    - 'Call by Object Reference'란 무엇인가?
- 제프 의견
    - 이 내용을 알게 되면 "변수에 값을 담는다"는 개념을 넘어설 수 있습니다.
    - **"변수는 객체를 가리키는 이름표(참조)일 뿐이다"**라는 사실을 파악하기 위한 주제입니다.
    - C언어의 포인터 개념을 Python스럽게 이해할 수 있게됩니다!

## 3. 제너레이터(Generator)와 이터레이터(Iterator): 지연 평가(Lazy Evaluation)

- **관련 주제 힌트:** 메모리 효율성, 스트림(Stream) 처리, 지연 평가(Lazy Evaluation)
- 조사 할 때 신경쓰면 좋은 것
    - List Comprehension(`[]`)과 Generator Expression(`()`)의 메모리 사용량 차이는? (`sys.getsizeof` 사용)
    - `yield` 키워드는 함수의 실행을 어떻게 '일시 정지' 시키는가?
    - 1억 개의 숫자를 다루는 반복문을 돌릴 때 리스트 대신 제너레이터를 써야 하는 이유는?
- 제프 의견
    - 반복문의 반복 횟수가 10억회라면?
    - 모든 데이터를 리스트에 담아두는 것과 필요할 때마다 생성하는 것의 차이를 정확하게 이해하게 됩니다.

## 4. 일급 객체(First-class Citizen)로서의 함수와 데코레이터(Decorator)

- **관련 주제 힌트:** 함수형 프로그래밍, 스코프(Scope), 클로저(Closure)
- 조사 할 때 신경쓰면 좋은 것
    - Python에서 함수를 다른 함수의 인자로 넘기거나, 리턴값으로 받을 수 있는가?
    - 함수 안에 함수를 정의했을 때(중첩 함수), 내부 함수가 외부 함수의 변수를 기억하는 '클로저(Closure)'란 무엇인가?
    - `@` 기호(데코레이터)를 사용하여 기존 코드를 수정하지 않고 기능을 추가하는 원리는 무엇인가?
- 제프 의견
    - 함수를 단순히 로직의 묶음으로 보는 것을 넘어서서 **함수 자체를 변수처럼 주고받는 고차 함수(Higher-order function)** 개념을 익힙니다.
    - 함수형 프로그래밍의 기초가 됩니다.
    - 코드가 익숙하지 않으면 코드 실행되는 순서 따라가다가 어지러울 수 있습니다. 초집중 하셔야해요.

## 5. 가비지 컬렉션(Garbage Collection): 객체의 소멸

- **관련 주제 힌트:** 운영체제(OS), 메모리 관리(Memory Management), 레퍼런스 카운팅(Reference Counting)
- 조사 할 때 신경쓰면 좋은 것
    - 더 이상 사용하지 않는 변수나 객체는 메모리에서 언제 사라지는가?
    - Python의 레퍼런스 카운트(Reference Count)란 무엇이며, 이것이 0이 되면 무슨 일이 일어나는가?
    - `del` 키워드는 객체를 삭제하는 것인가, 참조를 끊는 것인가?
    - 순환 참조(Circular Reference)가 발생하면 메모리 누수가 생길 수 있는데, Python의 GC는 이를 어떻게 해결하는가?
- 제프의견
    - 객체를 생성(`__init__`)하는 법은 배웠지요.
    - **초기화 된 이후에 해당 객체가 언제 메모리에서 사라지는지 정확하게 이해해 해야 합니다.**
    - 프로그램이 메모리를 어떻게 관리하고 해제하는지 알게 됩니다.

  
# 2. 주제 1번



# 주제 2번 (김동균)

## 2. Mutable vs Immutable: Python의 메모리 관리 모델

- **관련 주제 힌트:** 메모리 구조(Stack vs Heap), 포인터(Pointer), 참조(Reference), Call by Value vs Call by Reference
- 조사 할 때 신경쓰면 좋은 것
    - `a = [1, 2, 3]`일 때 `b = a`를 하고 `b`를 수정하면 왜 `a`도 바뀌는가? (Shallow Copy)
    - 반면, `a = 10`일 때 `b = a`를 하고 `b`를 수정해도 왜 `a`는 안 바뀌는가?
    - `id()` 함수를 사용하여 Mutable 객체(List)와 Immutable 객체(Tuple, Int)의 메모리 주소 변화를 추적해 보자.
    - 'Call by Object Reference'란 무엇인가?
- 제프 의견
    - 이 내용을 알게 되면 "변수에 값을 담는다"는 개념을 넘어설 수 있습니다.
    - **"변수는 객체를 가리키는 이름표(참조)일 뿐이다"**라는 사실을 파악하기 위한 주제입니다.
    - C언어의 포인터 개념을 Python스럽게 이해할 수 있게됩니다!

### python의 메모리 관리 모델

기본설명 :

메모리 관리방식에 따른 언어 구분

- 메모리 관리를 자동으로 실행해 주는 고수준 언어 java, python
- 메모리 관리를 수동으로 진행하는 저수준 언어 c, c++

python은 개발자가 직접 메모리를 참조하여 관리하는 모델이 아닌, 자동으로 참조값을 찾아 관리해주는 고급 프로그래밍 언어이며 (참조되지 않는 값은 GC로 이동하여 관리된다)

메모리의 2가지 영역 

- 스택 메모리 : 정적 메모리 할당,  (함수) 호출시 생성되는 지역 변수를 저장,  컴파일 시간에 크기가 결정됨,
- 힙 메모리 : 동적 메모리 할당, 런타임 시간에 크기가 결정됨

### 각 언어에서 메모리의 2가지 영역을 쓰는 방식

저수준 언어에서는 변수를 선언시 (stack, heap 개발자가 선택 영역)

- stack 메모리 에다가 변수가 실제로 사용하는 메모리의  사용량을 미리 지정하는 예약어(데이터 타입)를 통해 메모리 공간을 확보하여 변수값을 저장한다. 이는 물리적 메모리 주소값을 가지고 있으며 포인팅을 통해 해당값의 물리적 주소값을 직접 불러와서 사용한다. 이 작업은 stack 에서 이루어 진다.

- 하지만 함수가 종료되면 stack 메모리의 모든 값은 사라지고, 또한 런타임 당시에 필요한 메모리의 양을 동적으로 쓰기 위해서 저수준 언어에서도 heap 메모리를 사용한다. malloc() 같은 동적 할당 함수를 사용해야 하며 메모리 할당이 함수 호출 후 따로 관리 되지 않기 때문에 개발자가 free()를 통해 직접 닫아야 한다.

파이썬 같은 고수준 언어에서는 (stack, heap 두 가지 모두 사용)

- stack에는 변수의 이름과 참조 주소만 저장되고(c언어는 int +ptr 같은 실제 포인팅 작업해주어야 메모리 참조 값을 받는다. ↔ 이와 다르게 파이썬은 스텍 메모리에 딕셔너리 형식의 엔트리로 변수의 이름과 heap메모리를 지정하는 참조 정보가 매핑 구조로 담긴다. python 스택메모리의 참조 정보는 c언어 같은 실제 물리적 메모리 주소가 아니라 heap의 객체의 참조 주소이다. )
- 한편 heap 언어에 PyObject이라는 실제 객체를 가지고 있는 구조체가 저장된다. 이는 stack메모리의 참조값의 실제 정보이다.

### python 의 메모리 구조 방식

python은 모든 것을 객체로 저장하며 객체는 PyObject라는 구조체를 가지고 heap 메모리에 저장됨,  파이썬은 이 구조체를 ‘헤더로’ 관리하며 크게 3가지의 정보가 들어있다.

“데이터의 타입 헤더 인포”, 

“데이터의 참조 회수   : 객체가 참조되고 있는 횟수를 카운터 하며, 참조 횟수가 없으면 gc가 메모리에서 삭제”, 

“실제 데이터” 

### mutable  불별적인, immutable  가변적인의 차이

#### Mutable (가변 객체)

**"바꿀 수 있는"** 객체입니다. 객체의 메모리 주소를 유지하면서 그 안에 담긴 값만 자유롭게 수정할 수 있습니다.

- **대표적인 종류:** `list`, `dict`, `set`
- **특징:** 내부의 요소를 추가, 삭제, 수정해도 객체 자체의 메모리 주소(`id`)는 변하지 않습니다.

> 예시:
> 
1. 가변적 변수의 참조 정보 

`my_list = [1, 2]   # 메모리 주소 500번에 리스트 생성
my_list.append(3)  # 500번지 그 자리에서 데이터만 [1, 2, 3]으로 확장됨 (주소 고정)`

상기에 따라 파이썬의 heap메모리 영역에 리스트 pyobject 객체정보가 헤더로 저장된다.  스택 메모리에는 변수 이름과 heap메모리의 객체를 참조하는 참조값이 담긴다. 만약  list에 새로운 값을 추가한다면 변수 이름에 가르키는 주소값은 그대로 있고, heap영역에 데이터가 직접적으로 수정되는 것이므로 변수의 참조 주소는 동일하며,  객체의 데이터 값만 수정이 된다. append는 기존 객체의 데이터만을 수정한것으로 stack에서 가르키고 있는 참조 주소가 바뀌지 않았기 때문에 그대로 유지된다

1. 가변적 변수에 + 새로운 가변 변수가 추가될때 

`my_list = my_list + [3]` 

이와 같은 코드를 작동한다면 [3]의 새로운 리스트는 다른 객체이며 heap에 저장되는 별도의 객제가 된다. 결국 이를 저장하는 변수 역시 stack에 새로운 참조 주소를 가져야만 heap의 새로운 객체를 참조하기 떄문에 결과적으로 참조 주소 값이 바뀐다.

1. 가변적 변수 이름만 바뀔시에

a = [1, 2, 3]
b = a
b.append(4)
print(a) # 결과: [1, 2, 3, 4] (a도 같이 바뀜!)

상기에 따라 파이썬의 heap메모리 영역에 리스트 객체정 보가 헤더로 저장된다.  스택 메모리에는 변수 이름과 heap메모리의 객체를 참조하는 참조값이 담긴다.  변수 이름만 다르게 한다면, stack 매모리의 매핑 정보중 변수이름이 수정되고, 참조 주소는 그대로 갇고 있는 상태이다( 파이썬 같은 고급 언어는 gc의 원할한 동작을 위해 참조 주소를 임의로 조작하는 행위를 할 수 없다.) 결국 다른 변수의 이름일지라도 heap메모리의 객체의 동일 참조주소를 가지고 있기 때문에 (동일한 참조값을 보고 있기 때문에) 객체 데이터의 직접 수정이 일어나면 heap메모리를 참조하기 있던 stack 모든 변수들이 같이 움직인다.

#### Immutable (불변 객체)

말 그대로 **"바꿀 수 없는"** 객체입니다. 메모리에 한 번 올라가면 그 내용을 수정할 수 없습니다. 만약 값을 바꾸려고 하면, 파이썬은 기존 객체를 수정하는 대신 **새로운 객체를 생성**하여 메모리에 할당합니다.

- **대표적인 종류:** `int`, `float`, `str`, `tuple`, `bool`
- **특징:** 값이 변하면 참조하는 메모리 주소(`id`)도 함께 변합니다.

> 예시:
> 
> 
> `a = 10       # 메모리 주소 100번에 '10' 생성
> a = a + 1    # 100번지의 10을 11로 바꾸는 게 아니라, 200번지에 '11'을 새로 만들고 a가 거기를 가리키게 함`
> 

---

정수는 불변객체로 객체자체의 수정이 불가하며, 이는 heap메모리 상의 객체의 직접 수정이 불가하다는 소리이다. 결국 heap메모리상의 객체를 수정이 불가능 할 상태에서 stack메모리의 변수의 이름을 바꿔 버리면 바뀐 변수는 같은 heap메모리의 객체를 참조하는 것이 아니라 새로운 객체를 만들어 다른 주소를 참조하게 된다.

### Call by Value

# 주제 3번(양세윤)
[https://drive.google.com/file/d/1e4TKmck6e14IQjhboUuI-oinoFpsOpJp/view?usp=sharing](https://drive.google.com/file/d/1e4TKmck6e14IQjhboUuI-oinoFpsOpJp/view?usp=sharing)

# 주제 4번

# 주제 5번(김영우)

## Garbage Collector란? (쉽게 설명하자면…)
- 프로그램의 '**보이지 않는 청소부**'라고 불리는 **가비지 컬렉터**는, 더 이상 참조되지 않는 메모리를 자동으로 **회수**하여 시스템의 **안정성**을 높여주는 **핵심 엔진**입니다.
---
## 가비지 컬렉터는 왜 나왔지?
- 아주 예전 프로그래밍 방식은 모든 것이 **셀프 서비스**
    - **주문:** 요리(데이터)를 만들기 위해 테이블(메모리)을 직접 예약합니다.
    - **식사:** 음식을 맛있게 먹습니다(데이터 활용).
    - **치우기:** 다 먹고 나면 **반드시 본인이 직접 그릇을 치워야 합니다.**
- **문제 발생:**
    - 1. 사람이 깜빡하고 그릇을 안 치우면? 다음 손님이 앉을 자리가 없어서 식당이 꽉 차버립니다. (**메모리 누수**)
    - 2. 아직 먹고 있는데 직원이 치워버리거나, 이미 치웠는데 또 치우려고 하면? 사고가 납니다. (**시스템 오류**)
- 이러한 실수들을 막기 위해 현대적인 프로그래밍 방식은 가비지 컬렉션 (자동 청소 로봇)을 도입했다!!
    - **개발자의 실수 방지:** 사람이 직접 메모리를 치우다 보면 꼭 실수를 하는데, 이를 기계가 대신해서 안전해졌습니다.
    - **생산성 향상:** "어떻게 치울까?" 고민할 시간에 "어떤 기능을 만들까?"를 더 고민할 수 있게 되었습니다.
    - **시스템의 지속 가능성:** 쓰레기(안 쓰는 데이터)가 쌓여서 **컴퓨터가 느려지거나 멈추는 일을 원천 차단하기 위해서**입니다.

---
## 그럼 파이썬에서 가비지 컬렉터는 어떻게 동작하는 거지?

### 파이썬은 숫자 문자 함수 등 모든 데이터 타입을 객체(Object)로 간주하고 동작한다.

### 첫 번째 단계: 실시간 확인

- **가장 기본이 되는 방법!** → 각 객체는 **나를 사용중인 사람의 수**를 나타내는 **카운터가 붙어 있다.**
    - 만약 카운트가 0이 되면 **가비지 컬렉터**라는 청소기가 아 이 객체는 안쓰이는 구나 하고 판단하여 청소기로 객체를 빨아들인다!!

### 두 번째 방법! 끈질긴 쓰레기 찾기 (dead rock)

- 객체들이 서로를 붙잡고 있어서 카운트가 0이 되지 않는 “순환 참조"라는 까다로운 상황이 생길수도 있다. (A가 B를 잡고 B가 A를 잡고 있는 상태)
    - 가비지 컬렉터는 각 물건들을 생존 기간(0세대,1세대,2세대)로 나눈다.
    - 새로 생긴 물건들을 더 자주 검사(0세대)하고, 오래 살아남은 물건들은 (2세대)은 주인이 계속 쓰나 보다.. 하고 가끔만 검사한다. 이를 통해 효율적으로 서로 붙잡고만 있는 쓰레기들을 찾아내어 치운다.

### 즉 가비지 컬렉터는 모든 것이 객체라서 발생할 수 있는 메모리 고갈 문제를 해결해주는 도구!!

- 파이썬에서 기본적으로 가비지 컬렉션과 레퍼런스 카운팅을 통해 할당된 메모리를 관리한다.
    - 기본적으로 참조 횟수가 0  객체를 메모리에서 해제할 때 래퍼런스 카운팅 방식을 사용하지만 참조 횟수가 0은 아니지만, 도달할 수 없는 즉 순환 참조가 발생할 때 가비지 컬렉션으로 그 상황을 해결한다.

---

## 좀 더 깊게 설명하는 Python Garbage Collector Deep Dive

- GC는 현대적인 언어에는 거의 필수로 존재하며 개발자의 생산성을 향상해준다.
- 현대적인 언어인 C#, JS, Python 등의 언어는 GC를 기본적으로 제공하며, C,C++ 과 같은 언어에서는 malloc(), free()등과 같은 저수준의 메모리 관리 함수를 제공한다.
- GC는 메모리를 자동으로 관리해주는 **“과정” 당연히 자동으로 관리하므로 사람이 직접 관리하는 것 보다는 성능이 떨어짐**
    - 인스타그램은 Python GC를 사용하지 않음
    - [Luavis' Dev Story - Instagram이 Python garbage collection 없앤 이유](https://luavis.me/python/dismissing-python-garbage-collection-at-instagram)
- 성능이 중요한 프로그램에서는 GC 보다는 수동으로 메모리 관리 기능을 사용함

---

### 기존 메모 관리의 문제점

- 현대적인 언어가 아닌 과거 언어인 경우, **메모리 관리를 직접 해줘야 하는 언어 들은 기본적으로 크게 두 가지 문제점**을 가지고 있음
    - 필요 없는 메모리를 비우지 않았을 때, 메모리 사용을 마쳤을 때 비우지 않을 경우 **메모리 누수**가 발생함 → 장기적인 관점에서 심각한 문제
    - **사용중인 메모리 비우기**: 존재하지 않는 메모리에 접근하려고 하면 프로그램이 중단되거나 메모리 데이터 값이 손상될 수 있음
    - 이러한 문제를 해결하기 위해 현대적인 프로그래밍 언어는 GC (자동 메모리 관리)를 사용하게 됨

---

### Python에서 Garbace Collection 구현

- CPython에서의 메모리 관리 Garbage Collection은 두 가지 측면이 있다.
    1. 레퍼런스 카운팅 (Reference Counting)
    2. 세대별 가비지 컬렉터 (Generational Garbage Collection)

### CPython의 Refrence Counting

- Python에서 객체를 만들때마다 기본 C 객체에서는 Python (list,dict 또는 function)과 refrenece Count 생성된다.
    
    ```
    // Include/object.h (CPython 소스 코드 중 일부)
    typedef struct _object {
        _PyObject_HEAD_EXTRA    // 디버그용 매크로
        Py_ssize_t ob_refcnt;   // [핵심] 레퍼런스 카운트 변수
        struct _typeobject *ob_type; // 객체의 타입 정보를 담은 포인터
    } PyObject;
    ```
    
    - 파이썬의 모든 객체는 **C언어로 작성된 PyObject라는 구조를 기본**으로 한다.
    - 모든 타입이 객체로 간주되는 이유는 모든 객체가 이 **구조체를 상속**받기 때문이다.
- 매우 기본적으로 Python 객체의 Reference 카운트는 객체가 참조될 때 마다 증가하고 객체의 참조 해제될 때 감소한다.
- 객체의 Reference Count가 0이 되면 **객체의 메모 할당이 해제된다.**

---

### Python Reference Counting
- sys 모듈을 통해서 특정 객체의 참조 회수 (Reference Count)를 확인할 수 있음
- 참조 횟수가 2인 이유는 변수를 생성할 때 두 번째는 변수 a를 sys.getrefcount(a) 함수에 전달할
- 변수를 자료 구조 (set,stack,queue..)혹은 각 리스트나 dict에 추가하면 참조 횟수가 증가한다.

- 위 코드처럼 list나 dict에 추가될 때 마다 a의 참조 횟수가 증가한다.

### **Generational Garbage Collection**

- Python은 메모리 관리를 위해 레퍼런스 카운팅 외에도 세대별 가비지 컬렉터 (generation garbage collection)이라는 방법을 사용한다.
- 대부분 레퍼런스 카운팅이 주로 사용되지만 보조로 가비지 컬렉션을 사용한다.
- 가비지 컬렉션을 사용하는 이유는 **순환 참조**를 막기 위해서다.

- a의 참조 횟수는 1이지만 이 객체는 더 이상 접근할 수 없음 (객체의 참조를 해제 했으므로 접근 불가, 메모리에서 해제 불가)
    
    ## `a = []`
    
    - 빈 리스트 객체가 하나 만들어짐
    - 변수 `a`가 그 리스트를 가리킴
        
        → **참조 수(reference count) = 1**
        
        `a.append(a)`
        
        - 리스트 안에 **자기 자신을 요소로 추가**
        - 참조 수 1
        
        ## `del a`
        
        - 변수 `a`가 사라짐
        - 하지만 리스트 내부에는 여전히 **자기 자신을 가리키는 참조**가 있음
        
        → **참조 수 = 1**
        
- 또 다른 예로는 서로를 참조하는 객체

```
>>> a = Func_pr() # 0x01
>>> b = Func_pr() # 0x02
>>> a.x = b # 0x01의 x는 0x02를 가리킨다.
>>> b.x = a # 0x02의 x는 0x01를 가리킨다.
# 0x01의 레퍼런스 카운트는 a와 b.x로 2다.
# 0x02의 레퍼런스 카운트는 b와 a.x로 2다.
>>> del a # 0x01은 1로 감소한다. 0x02는 b와 0x01.x로 2다.
>>> del b # 0x02는 1로 감소한다.
```

- 0x01과 0x02과 서로를 참조하고 있기 때문에 카운트는 1이지 둘 다 0에 도달 할 수없음 garbage가 됨

---

### Garbage Collection generation (세대)

- 가비지 컬렉터는 메모리의 모든 객체를 추적한다. 새로운 객체는 1세대 가비지 수집기에서 수명을 시작한다.
    - Python이 세대에서 가비지 수집 프로세를 실행하고 객체가 살아남으면, 두 번째 이 세대로 올라간다.
    - Python 가비지 수집기는, 총 3세대이며, 객체는 현재 세대 가비지 수집 프로세스에서 살아남을 때마다 이전 세대로 이동한다.
- 두 번째 핵심 개념은 thresold(임계) 값이다. 각 세대 마다 가비지 컬렉터 모듈에는 임계값 개수의 개체가 있다.
- 가비지 컬렉터는 내부적으로 generation(세대)과 threshold(임계값)으로 가비지 컬렉션 주기 객체를 관리한다.
- 객체 수가 해당 임계값을 넘게 되면 가비지 컬렉션이 컬렉션 프로세스를 추적하게 된다.
    - 기본 임계값은 (700, 10, 10)
- 해당 프로세스에서 살아남게 된 객체는 이전 세대로 옮겨 지게 된다.(즉 0세대에서 살아남으면 1세대 → 2세대)
- 당연히 한 객체는 단 하나의 세대에만 속한다. 가비지 컬렉터는 0세대 일수록 더 자주 가비지 컬렉션을 하도록 설계되어 있다.
    - 대부분 오랜 객체보다 어린 객체가 해제 될 가능성이 더 높기 때문이다.
    - 가비지 컬렉터는 특정상황에서 성능 저하를 초래 할 수 있다.
    - 순환참조가 많은 경우
        - 추가적인 메모리 그래프를 탐색해서 순환 검출을 해야 하기 때문에 시간이 오래 걸릴 수 있음
    - 객체 생성 및 소멸이 빈번한 경우
        - 매우 빈번하게 객체가 생성되면 0세대에서 계속해서 가비지 컬렉션이 발생
    - 모든 실행 중단 현상
        - 가비지 컬렉션 실행 시 모든 실행중인 스레드가 일시적으로 중단됨
        - 안전하게 메모리를 관리하고 일관성을 유지하려면 작업을 잠시 멈춰 메모리에 접근하는 것을 방지해야 하기 때문
        - 멀티스레드 프로그램에서 특히 성능 저하가 두드러질 수 있음

```
//세대별 임계값 설정 로직 (gc_set_threshold_impl)
static PyObject *
gc_set_threshold_impl(PyObject *module, int threshold0, int group_right_1,
                      int threshold1, int group_right_2, int threshold2)
{
    GCState *gcstate = get_gc_state();

    // threshold0은 0세대(young)의 임계값입니다.
    // 임계값은 700
    gcstate->young.threshold = threshold0;
    
    // threshold1은 1세대(old[0])의 임계값입니다.
    // 임계값은 10
    if (group_right_1) {
        gcstate->old[0].threshold = threshold1;
    }
    
    // threshold2는 2세대(old[1])의 임계값입니다.
    // 임계값은 10
    if (group_right_2) {
        gcstate->old[1].threshold = threshold2;
    }
    Py_RETURN_NONE;
}
```

### 순환 참조란 그리고 순환 참조하는 방식?

- **두 개 이상의 객체나 모듈이 서로를 직접 또는 간접적으로 가리키며 맞물려 있어서, 어느 한쪽도 완전히 참조를 해제하거나 완료할 수 없는 상태**
- 모든 파이썬 객체가 순환 참조의 대상은 아님 (int,str 같은 원자적 타입 제외)
- 리스트,딕셔너리, 클래스 인스턴스와 같은 대상이 컨테이너 객체만 해당됨, CPython은 이를 추적하기 위해 일반적인 `PyObject` 헤더 앞에 `PyGC_Head`라는 추가적인 구조체를 붙임

```
/* Include/internal/pycore_gc.h */
typedef struct _gc_head {
    struct _gc_head *gc_next; // 더블 링크드 리스트 포인터
    struct _gc_head *gc_prev;
    Py_ssize_t _gc_prev;      // 참조 횟수 복사본 및 상태 저장용
} PyGC_Head;
```

- 이 헤더를 통해 모든 컨테이너 객체는 각 세대(0,1,2)세대를 나타내는 더블 링크드 리스트에 연결됨
    
    ### step 1: 참조 횟수 복사(update_refs)
    
    - 참조 횟수를 복사하는 이유는 실제 참조 횟수를 건드리지 않고 연산을 수행하기 위해
    
    ### **Step 2: 참조 그래프 순회 및 감산 (`subtract_refs`)**
    
    - 세대의 모든 객체를 순회하며, 각 객체가 참조하고 있는 다른 객체들을 찾아갑니다. 이때 각 객체에 정의된 **`tp_traverse`** 함수를 호출
    - 객체 `A`가 객체 `B`를 참조하고 있다면, `B`의 임시 참조 횟수(`gc_refs`)를 **1 감소**
    - 이 과정을 세대 내 모든 객체에 대해 수행
    
    ### Step 3: 도달 가능성 판별 (`move_unreachable`)
    
    - **Reachable (도달 가능):** `gc_refs`가 1 이상인 객체입니다. 외부 참조가 살아있다는 증거
    - **Tentatively Unreachable (잠정적 도달 불가능):** `gc_refs`가 0인 객체입니다. 자기들끼리 순환 참조 중이거나, Reachable 객체로부터 연결되어 있을 가능성
    
    ### Step 4: 도달 가능성 전파 (`scan_reachable`)
    
    가장 중요한 단계입니다. **Reachable 그룹에 속한 객체가 참조하는 모든 객체는 다시 Reachable로 복구**
    
    - 예를 들어, `A`가 Reachable이고 `A`가 `B`를 참조하고 있다면, `B`의 `gc_refs`가 0이었더라도 `B`는 다시 Reachable 그룹으로 이동
    - 이 과정이 끝나고도 여전히 `gc_refs`가 0인 채로 남은 객체들이 **실제 순환 참조 쓰레기**
    - **Finalization:** `Unreachable`로 확정된 객체들을 순회하며 파이썬 소멸자(`__del__`)가 있다면 실행 준비를
    - **Deallocation:** 실제 C의 `free()`와 유사한 `tp_dealloc`을 호출하여 메모리를 해제
    - **Promotion:** 검사 후에도 살아남은 `Reachable` 객체들은 다음 세대(0세대 → 1세대, 1세대 → 2세대)로 이동."오래 살아남은 객체는 앞으로도 오래 살 것이다"라는 가설에 따라 검사 빈도를 낮추기 위함

---