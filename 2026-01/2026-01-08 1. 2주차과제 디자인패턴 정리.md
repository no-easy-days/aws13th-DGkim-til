# 1. 객체지향적 디자인패턴이란?

객체 지향 프로그래밍의 순서

객체지향 설계(OOD)를 진행할 때, 설계를 **'부품 만들기 → 부품 조립하기 → 완제품 인터페이스 제공하기'**의 단계로 나누어 생각하는 것은 아주 훌륭한 접근입니다.

각 단계에서 추구하는 목적과 그 목적을 달성하기 위해 사용되는 대표적인 디자인 패턴들을 정리해 드립니다.

---

## 1. 객체의 정의 (Structural & Behavioral)

**목적:** 객체의 데이터와 책임을 명확히 하고, 객체 간의 구조적 관계를 설정합니다.

| 적용 패턴 | 설명 및 목적 | 도서관 시스템 예시 |
| --- | --- | --- |
| **데코레이터 (Decorator)** | 객체에 동적으로 새로운 책임을 추가합니다. | 기본 도서에 '희귀본', '멀티미디어 자료' 등의 기능을 덧씌울 때 |
| **어댑터 (Adapter)** | 인터페이스가 호환되지 않는 클래스들을 연결합니다. | 외부 서점 API나 구형 데이터베이스 시스템을 우리 코드에 맞출 때 |
| **컴포지트 (Composite)** | 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현합니다. | '개별 도서'와 이들을 묶은 '도서 세트'를 동일하게 취급할 때 |

---

## 2. 객체의 생성 및 행동 전략 (Creational & Behavioral)

**목적:** 객체를 직접 생성(`new`)하지 않고 유연하게 만들며, 실행 중에 객체의 행동(알고리즘)을 바꿀 수 있게 합니다.

| 적용 패턴 | 설명 및 목적 | 도서관 시스템 예시 |
| --- | --- | --- |
| **팩토리 메서드 (Factory)** | 객체 생성 로직을 캡슐화하여 서브클래스나 전담 클래스에 위임합니다. | 도서 종류(잡지, 전공서, 소설)에 따라 적절한 객체를 자동 생성할 때 |
| **전략 (Strategy)** | 알고리즘(행동)을 정의하고 각각을 캡슐화하여 교체 가능하게 합니다. | 검색 로직(제목검색, ISBN검색)이나 연체료 계산 방식의 교체 |
| **싱글톤 (Singleton)** | 특정 클래스의 인스턴스가 오직 하나만 존재하도록 보장합니다. | 시스템 전체에서 단 하나의 `Library` 데이터 관리자 유지 |
| **상태 (State)** | 객체의 내부 상태에 따라 스스로 행동을 변경하게 합니다. | 도서가 '대출가능', '대출중', '연체중' 상태에 따라 대출 버튼 활성/비활성 결정 |

---

## 싱글톤 패턴이란?

하나의 클래스에 대해 어플리케이션이 한번만 메모리를 할당하고, 그 메모리에 인스턴스를 생성합니다. 즉, 싱글톤은 하나의 클래스에 단 하나의 인스턴스만을 허용하는 패턴입니다.

싱글톤 패턴을 사용하는 이유

1. 고정된 메모리영역에, 단 하나의 인스턴스만 생성하기 때문에 메모리 낭비를 방지할 수 있습니다.
2. 인스턴스가 전역적으로 사용될 수 있기에 다른 클래스의 인스턴스들이 데이터를 공유하고 변경할 수 있습니다.
3. 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우에 싱글톤 패턴을 사용하기도 합니다.


싱글톤 패턴의 문제점

1. 싱글톤 인스턴스에게 많은일을 위임하거나 데이터를 공유시킬 경우 다른 클래스의 인스턴스간에 결합도가 높아져 개방폐쇄원칙에 위배 됩니다.
2. 멀티스레드 환경에서 데이터 동기화 문제가 발생할 수 있습니다

---

## 전략 패턴


---

## 3. 시스템 통합 및 소통 (Structural & Behavioral)

**목적:** 분리된 객체들을 하나로 묶어 사용자에게 편리한 입구를 제공하거나, 객체 간의 복잡한 통신을 조율합니다.

| 적용 패턴 | 설명 및 목적 | 도서관 시스템 예시 |
| --- | --- | --- |
| **퍼사드 (Facade)** | 복잡한 서브시스템에 대한 통합된 인터페이스를 제공합니다. | `main.py`가 여러 객체를 직접 다루지 않고 `LibrarySystem` 하나만 상대함 |
| **옵저버 (Observer)** | 객체의 상태 변화를 관찰자들에게 자동으로 알립니다. | 책이 반납되면 해당 책을 예약한 회원들에게 알림 메시지 발송 |
| **중재자 (Mediator)** | 객체 간의 복잡한 상호작용을 한 클래스에 집중시켜 결합도를 낮춥니다. | 회원, 도서, 대출 기록 간의 복잡한 연산 로직을 한데 모아 관리 |

---


## 퍼사드 패턴

## 💡 요약: 도서관 프로젝트를 위한 로드맵

지금 단계에서 이 모든 패턴을 다 쓸 필요는 없습니다. 객체지향의 정수를 맛보기 위해 **추천하는 학습 순서**는 다음과 같습니다.

1. **싱글톤 (2단계):** 데이터의 일관성을 위해 `Library` 객체를 하나로 고정.
2. **전략 (2단계):** 검색 기능을 다양화하면서 알고리즘 분리 학습.
3. **퍼사드 (3단계):** 복잡해진 `main.py`의 로직을 캡슐화하여 코드 정리.
4. **옵저버 (3단계):** 대출/반납 상태 변화에 따른 자동 알림 기능 추가.


---

# 2. 도서관 프로그램 적용할만한 디자인 패턴은?

도서관 관리 프로그램은 객체 간의 상태 변화가 잦고, 데이터 저장 방식이나 검색 방식이 확장될 가능성이 높기 때문에 
여러 가지 디자인 패턴을 적용하기 아주 좋은 프로젝트입니다.

현재 코드에서 더 발전된 객체지향적 디자인 패턴 3가지를 추천해 드립니다.

1. 전략 패턴 (Strategy Pattern)
적용 대상: 도서 검색 기능 현재 search_book은 제목으로만 검색하지만, 나중에는 '저자명 검색', 'ISBN 검색', '출판사 검색' 등 다양한 방식이 필요할 수 있습니다. 이때 검색 알고리즘을 별도의 클래스로 분리하여 런타임에 교체할 수 있게 만듭니다.

이점: 새로운 검색 방식이 추가되어도 Library 클래스의 코드를 수정할 필요가 없습니다. (개방-폐쇄 원칙 준수)

2. 싱글톤 패턴 (Singleton Pattern)
적용 대상: Library 클래스 도서관 시스템에서 Library 객체는 단 하나만 존재해야 합니다. 만약 실수로 Library()를 여러 번 호출하여 객체가 여러 개 생성되면, 각각 다른 메모리와 파일에 접근하게 되어 데이터가 꼬일 수 있습니다.

이점: 프로그램 전체에서 하나의 도서관 데이터(장서 목록, 회원 목록)를 안전하게 공유할 수 있습니다.

Python
class Library:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Library, cls).__new__(cls)
        return cls._instance
3. 옵저버 패턴 (Observer Pattern)
적용 대상: 연체 및 상태 알림 시스템 책의 상태가 '대출 중'에서 '반납 가능'으로 바뀌거나, 반납 기한이 지났을 때 회원에게 알림을 보내야 하는 경우입니다. Book 객체의 상태가 변하면 이를 감시하는 NotificationService가 자동으로 동작하게 만듭니다.

이점: 도서 객체와 알림(SMS, Email 등) 로직을 분리하여 결합도를 낮출 수 있습니다.

4. 추천하는 첫 번째 적용 단계: "팩토리 패턴 (Factory Pattern)"
가장 먼저 적용해 볼 만한 패턴은 팩토리 패턴입니다. 현재 main.py에서 Book(...)이나 Member(...)를 직접 생성하고 있는데, 이를 전담하는 클래스를 만드는 것입니다.

적용 예시 (models.py 수정)
Python
class LibraryFactory:
    @staticmethod
    def create_book(title, author, isbn):
        # 생성 전 유효성 검사 로직을 여기에 위임
        return Book(title, author, isbn)

    @staticmethod
    def create_member(name, phone):
        return Member(name, phone)

왜 이 패턴들을 써야 할까요?
유지보수성: 코드가 커져도 어디를 수정해야 할지 명확해집니다.

테스트 용이성: 각 패턴별로 독립적인 유닛 테스트가 가능해집니다.

전문성: 단순한 기능을 구현하는 것을 넘어, "변화에 유연한 구조"를 설계하는 능력을 키울 수 있습니다.

이 중에서 전략 패턴을 이용해 검색 기능을 고도화해 보거나, 싱글톤을 적용해 데이터 안정성을 높여보는 것은 어떠신가요? 원하시는 패턴을 고르시면 해당 코드를 작성해 드릴 수 있습니다.

---

# 3. 추천한 각각의 디자인 패턴이 도서관 프로그램에 왜 '객체지향적 프로그래밍'을 달성하는데 필요한지 설명해줘

디자인 패턴을 적용하는 근본적인 이유는 단순히 코드를 예쁘게 만드는 것이 아니라, **객체지향 프로그래밍(OOP)의 5대 원칙(SOLID)**을 실현하여 **"변화에 유연하고 관리가 쉬운 코드"**를 만들기 위함입니다.

추천해 드린 세 가지 패턴이 어떻게 OOP의 가치를 실현하는지 설명해 드릴게요.

1. 전략 패턴 (Strategy Pattern)
[OOP 핵심 가치: 다형성(Polymorphism) & 개방-폐쇄 원칙(OCP)]

필요한 이유: 지금은 책을 '제목'으로만 찾지만, 나중에 '저자', 'ISBN', '출판 날짜' 등으로 검색 기능이 늘어날 때마다 if-else 문을 추가해야 한다면 코드는 점점 지저분해집니다.

객체지향적 달성: 검색 알고리즘 자체를 하나의 **'전략 객체'**로 봅니다. Library는 "어떻게 검색하는지" 몰라도 됩니다. 그저 검색 객체에게 "찾아줘"라고 부탁할 뿐이죠. 새로운 검색법이 추가되어도 기존 Library 코드를 한 줄도 건드리지 않고 확장할 수 있게 됩니다.

2. 싱글톤 패턴 (Singleton Pattern)
[OOP 핵심 가치: 객체의 책임과 정보의 일관성]

필요한 이유: 실제 세계에서 도서관 건물은 하나인데, 프로그램 안에서 실수로 Library 객체를 2개 만들면 어떻게 될까요? A 도서관에서는 책이 대출되었다고 나오는데, B 도서관에서는 대출 가능하다고 나오는 데이터 불일치가 발생합니다.

객체지향적 달성: 시스템 전체에서 **"상태를 가진 단 하나의 객체"**를 보장함으로써 데이터의 무결성을 지킵니다. 이는 객체가 가진 정보를 신뢰할 수 있게 만들며, 전역적인 리소스 관리에 대한 책임을 명확히 합니다.

3. 옵저버 패턴 (Observer Pattern)
[OOP 핵심 가치: 느슨한 결합(Loose Coupling)]

필요한 이유: 책이 반납되었을 때 대기 중인 회원에게 문자를 보내고 싶다고 가정해 봅시다. Book 클래스 안에 문자 발송 로직을 직접 넣으면, 나중에 "이메일 알림"으로 바꿀 때 Book 클래스를 수정해야 합니다. 책 객체가 문자 발송 기능까지 알아야 할까요? (이것은 단일 책임 원칙(SRP) 위반입니다.)

객체지향적 달성: Book은 상태가 변했다는 사실만 외부에 알리고(Publish), 알림 서비스(Observer)가 이를 가로채서 처리합니다. 둘은 서로의 내부 로직을 모르며 독립적으로 존재하므로, 알림 기능이 수백 개 추가되어도 도서 객체는 영향을 받지 않습니다.

4. 팩토리 패턴 (Factory Pattern)
[OOP 핵심 가치: 캡슐화(Encapsulation) & 객체 생성 로직의 분리]

필요한 이유: main.py에서 Book(title, author, isbn)을 직접 호출하는 것은, 사용자가 공장에 들어가서 기계를 직접 조작하는 것과 같습니다. 만약 나중에 Book 생성자에 '가격'이나 '출판사' 파라미터가 추가되면 main.py의 모든 곳을 다 고쳐야 합니다.

객체지향적 달성: 객체 생성 과정을 **팩토리(공장)**에 숨깁니다. main.py는 팩토리에 "책 하나 만들어줘"라고 요청만 합니다. 내부적으로 어떤 유효성 검사를 하는지, 어떤 파라미터가 들어가는지는 팩토리만 알면 되므로 구현 세부사항이 캡슐화됩니다.

💡 요약하자면
이 패턴들을 적용하는 것은 결국 **"객체들이 서로의 사생활(내부 로직)에 참견하지 않으면서도, 맡은 일만 잘하게 만드는 것"**입니다. 이것이 바로 객체지향이 추구하는 자율적인 객체들의 협력입니다.

가장 먼저 어떤 패턴을 코드로 직접 구현해보고 싶으신가요? **검색 기능을 유연하게 만드는 '전략 패턴'**부터 시작해보는 것을 추천합니다! Would you like me to show you how to implement the Strategy Pattern for your search function?

---

# 4. 실제 디자인패턴을 과제에 적용해 보기

## 싱글톤 패턴
파이썬의 객체 지향 프로그래밍 방식으로는 클래스는 싱글톤화 하는것도 있지만, 모듈화도 있다.
싱글톤을 하면 단위 테스트가 어렵다. 즉 인스턴스가 하나만 생성된다는 것은 다른 단위테스트에 해당 인스턴스가 영향을 받을 수 있다는 것과 동의어이다.

---

### 1. 파이썬 모듈은 그 자체로 '싱글톤'입니다

파이썬에서 모듈(`utils.py`, `models.py` 등)은 프로그램 실행 중 단 한 번만 임포트(Import)됩니다.

* **동작 방식:** `import models`를 여러 번 호출해도 파이썬은 이미 메모리에 로드된 객체를 재사용합니다.
* **모듈화 방식:** `Library` 클래스를 만들지 않고, `library_data.py`라는 파일에 변수와 함수만 나열해두면 프로그램 전체에서 하나의 데이터만 공유하게 됩니다.

---

### 2. 모듈 방식 vs 싱글톤 패턴 비교

| 구분 | 모듈 방식 (Module-as-a-Singleton) | 싱글톤 패턴 (Class-based Singleton) |
| --- | --- | --- |
| **장점** | 코드가 간결하고 파이썬답다(Pythonic). 관리가 매우 쉽다. | 상속이 가능하며, 객체지향적 기능을 모두 활용할 수 있다. |
| **초기화 제어** | 임포트 시점에 바로 실행되어 제어가 어렵다. | `getInstance()` 호출 시점에 **지연 초기화(Lazy Initialization)**가 가능하다. |
| **유연성** | 데이터 구조를 변경하거나 교체하기 어렵다. | 인터페이스나 추상 클래스를 상속받아 **다형성**을 구현할 수 있다. |
| **테스트** | 모듈 전체의 상태를 초기화하기 까다롭다. | 객체를 교체(Mocking)하거나 초기화하기가 상대적으로 쉽다. |

---

### 3. 왜 모듈화보다 싱글톤 패턴이 '더 객체지향적'일까?

이 질문에 대한 핵심 답변부터 드리자면, **"모듈화는 인스턴스를 명시적으로 생성하지 않지만, 파이썬에서는 그 모듈 자체가 하나의 '객체'로 취급되기 때문에 넓은 의미의 객체지향을 실천하는 것"**이라고 볼 수 있습니다.

다만, 엄격한 의미의 **객체지향 설계(OOD)** 관점에서 왜 모듈보다 클래스를 선호하는지 그 차이를 명확히 짚어드릴게요.

---

#### 1. 모듈화가 '객체지향적이지 않다'고 느껴지는 이유 (한계점)

객체지향의 4대 요소 중 **상속(Inheritance)**과 **다형성(Polymorphism)** 측면에서 모듈은 클래스를 따라가기 어렵습니다.

* **상속의 불가능:** `library_module.py`라는 모듈을 만들면, 이를 상속받아 기능을 확장한 `digital_library_module.py`를 만들 수 없습니다. 코드를 복사해서 새로 만들거나 내부 로직을 수정해야 하죠.
* **다형성의 부재:** 프로그램 실행 중에 "일반 도서관 모듈"을 "대학교 도서관 모듈"로 **갈아 끼우는 행위**가 불가능합니다. 클래스는 같은 부모를 둔 서로 다른 자식 인스턴스를 변수에 할당하기만 하면 되지만, 모듈은 물리적인 파일 구조에 묶여 있습니다.

#### 2. 모듈도 '객체지향적'일 수 있는 이유 (파이썬의 특징)

파이썬에서 모듈은 사실 `module` 클래스의 **인스턴스**입니다.

* **캡슐화(Encapsulation):** 모듈 내부에 변수와 함수를 모아두고 외부에서 접근을 제어(추상화)하므로 캡슐화의 원리를 따르고 있습니다.
* **싱글톤의 자동 구현:** 앞서 논의했듯, 파이썬은 모듈을 단 한 번만 로드하므로 메모리 관리 측면에서는 매우 효율적인 싱글톤 객체처럼 동작합니다.

---

#### 3. 클래스 인스턴스 vs 모듈화 비교

| 구분 | 클래스 인스턴스 (객체) | 모듈 (Module) |
| --- | --- | --- |
| **청사진(Blueprint)** | 하나의 설계도로 여러 개를 찍어낼 수 있음 (분점 가능) | 그 자체가 실체이며 단 하나만 존재함 (본점만 가능) |
| **데이터 보호** | `_`나 `__`를 통해 내부 속성 은닉이 용이함 | 모듈 내 변수는 어디서든 접근하기 쉬움 (보안 취약) |
| **확장성** | 상속을 통해 기능을 물려주고 바꿀 수 있음 | 기능을 확장하려면 파일을 직접 수정해야 함 |
| **유연성** | 런타임에 객체의 종류를 바꿀 수 있음 (다형성) | 임포트 시점에 고정됨 |

---

### 4. 결론: "도서관 프로그램"에는 어떤 것이 더 맞을까?


* **단순한 전역 설정이나 데이터 공유**가 목적이라면: **모듈화**가 정답입니다. 파이썬에서는 이것이 훨씬 깔끔합니다.
* **객체 간의 관계(상속, 인터페이스 준수)가 중요**하고, 나중에 시스템이 확장될 가능성이 높다면: **싱글톤 패턴**이 더 객체지향적 설계에 가깝습니다.

현재 도서관 코드의 경우, 단순히 데이터를 담는 수준이라면 모듈화로 충분하지만, **"도서관이라는 주체"가 다른 객체(회원, 도서)와 복잡하게 상호작용**하므로 클래스 구조를 유지하는 싱글톤 방식이 향후 디자인 패턴(전략, 옵저버 등)을 덧붙이기에 더 유리합니다.

**"클래스의 힘을 빌려 확장성을 챙길 것인가, 모듈의 단순함으로 생산성을 챙길 것인가"**의 선택인 셈이죠.


만약 당신의 프로그램이 **"전 세계에 딱 하나뿐인 유일한 시스템"**이고 앞으로 확장이 전혀 필요 없다면 
또는 
* **단순한 전역 설정이나 데이터 공유**가 목적이라면: **모듈화**가 정답입니다. 파이썬에서는 이것이 훨씬 깔끔합니다.


하지만 다음과 같은 상황이 예상된다면 **클래스 기반의 객체지향**이 훨씬 강력합니다.

1. **확장:** "우리 도서관은 일반 도서관인데, 나중에 어린이 도서관 기능도 추가될 거야." (상속 필요)
2. **다양성:** "지역에 따라 대출 규정이 다른 여러 개의 도서관 객체를 관리해야 해." (다수 인스턴스 필요)
3. **교체:** "테스트할 때는 가짜 데이터를 가진 도서관 객체를 쓰고 싶어." (의존성 주입 필요)

**결국 "객체지향적이지 않다"기보다는 "객체지향의 강력한 무기(상속, 다형성)를 포기하는 것"에 가깝습니다.**

사용자님은 현재 코드에서 **확장 가능성**을 중요하게 생각하시나요, 아니면 **단순함과 명료함**을 더 중요하게 생각하시나요? 그 선택에 따라 설계의 방향이 완전히 달라집니다.

질문하신 **객체지향 추구 목적** 측면에서 보면, 싱글톤 패턴은 다음과 같은 강력한 무기를 가집니다.

#### ① 다형성(Polymorphism) 활용

만약 나중에 도서관 시스템을 확장해서 `DigitalLibrary`와 `PhysicalLibrary` 중 하나를 선택해 운영해야 한다면?

* **모듈 방식:** `if` 문으로 모든 함수 내부 로직을 분기하거나 파일 자체를 바꿔야 합니다.
* **싱글톤 패턴:** `Library`라는 부모 클래스를 상속받은 서로 다른 자식 클래스들을 싱글톤으로 갈아 끼울 수 있습니다.

### ② 명확한 생명주기 관리

모듈은 프로그램이 시작될 때 메모리에 올라가서 끝날 때까지 내려오지 않습니다. 반면 클래스 기반 싱글톤은 **"특정 시점에 데이터를 로드"**하거나 **"메모리에서 명시적으로 해제"**하는 등의 세밀한 제어가 가능합니다.

### ③ 상태와 행위의 캡슐화

모듈 방식은 전역 변수(Global Variable)를 쓰는 것과 유사한 위험(의도치 않은 데이터 수정 등)이 있습니다. 싱글톤 패턴은 `private`한 속성(파이썬에서는 `_` 접두사)을 사용하여 **내부 데이터를 보호(캡슐화)**하고 정해진 메서드를 통해서만 접근하게 강제할 수 있습니다.

---
