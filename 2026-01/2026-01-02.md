
### 2. Mutable vs Immutable: Python의 메모리 관리 모델

- **관련 주제 힌트:** 메모리 구조(Stack vs Heap), 포인터(Pointer), 참조(Reference), Call by Value vs Call by Reference
- 조사 할 때 신경쓰면 좋은 것
    - `a = [1, 2, 3]`일 때 `b = a`를 하고 `b`를 수정하면 왜 `a`도 바뀌는가? (Shallow Copy)
    - 반면, `a = 10`일 때 `b = a`를 하고 `b`를 수정해도 왜 `a`는 안 바뀌는가?
    - `id()` 함수를 사용하여 Mutable 객체(List)와 Immutable 객체(Tuple, Int)의 메모리 주소 변화를 추적해 보자.
    - 'Call by Object Reference'란 무엇인가?
- 제프 의견
    - 이 내용을 알게 되면 "변수에 값을 담는다"는 개념을 넘어설 수 있습니다.
    - **"변수는 객체를 가리키는 이름표(참조)일 뿐이다"**라는 사실을 파악하기 위한 주제입니다.
    - C언어의 포인터 개념을 Python스럽게 이해할 수 있게됩니다!

python의 메모리 관리 모델

# 기본설명 :

메모리 관리방식에 따른 언어 구분

- 메모리 관리를 자동으로 실행해 주는 고수준 언어 java, python
- 메모리 관리를 수동으로 진행하는 저수준 언어 c, c++

python은 개발자가 직접 메모리를 참조하여 관리하는 모델이 아닌, 자동으로 참조값을 찾아 관리해주는 고급 프로그래밍 언어이며 (참조되지 않는 값은 GC로 이동하여 관리된다)

메모리의 2가지 영역 

- 스택 메모리 : 정적 메모리 할당,  (함수) 호출시 생성되는 지역 변수를 저장,  컴파일 시간에 크기가 결정됨,
- 힙 메모리 : 동적 메모리 할당, 런타임 시간에 크기가 결정됨

# 각 언어에서 메모리의 2가지 영역을 쓰는 방식

저수준 언어에서는 변수를 선언시 (stack, heap 개발자가 선택 영역)

- stack 메모리 에다가 변수가 실제로 사용하는 메모리의  사용량을 미리 지정하는 예약어(데이터 타입)를 통해 메모리 공간을 확보하여 변수값을 저장한다. 이는 물리적 메모리 주소값을 가지고 있으며 포인팅을 통해 해당값의 물리적 주소값을 직접 불러와서 사용한다. 이 작업은 stack 에서 이루어 진다.

- 하지만 함수가 종료되면 stack 메모리의 모든 값은 사라지고, 또한 런타임 당시에 필요한 메모리의 양을 동적으로 쓰기 위해서 저수준 언어에서도 heap 메모리를 사용한다. malloc() 같은 동적 할당 함수를 사용해야 하며 메모리 할당이 함수 호출 후 따로 관리 되지 않기 때문에 개발자가 free()를 통해 직접 닫아야 한다.

파이썬 같은 고수준 언어에서는 (stack, heap 두 가지 모두 사용)

- stack에는 변수의 이름과 참조 주소만 저장되고(c언어는 int +ptr 같은 실제 포인팅 작업해주어야 메모리 참조 값을 받는다. ↔ 이와 다르게 파이썬은 스텍 메모리에 딕셔너리 형식의 엔트리로 변수의 이름과 heap메모리를 지정하는 참조 정보가 매핑 구조로 담긴다. python 스택메모리의 참조 정보는 c언어 같은 실제 물리적 메모리 주소가 아니라 heap의 객체의 참조 주소이다. )
- 한편 heap 언어에 PyObject이라는 실제 객체를 가지고 있는 구조체가 저장된다. 이는 stack메모리의 참조값의 실제 정보이다.

# python 의 메모리 구조 방식

python은 모든 것을 객체로 저장하며 객체는 PyObject라는 구조체를 가지고 heap 메모리에 저장됨,  파이썬은 이 구조체를 ‘헤더로’ 관리하며 크게 3가지의 정보가 들어있다.

“데이터의 타입 헤더 인포”, 

“데이터의 참조 회수   : 객체가 참조되고 있는 횟수를 카운터 하며, 참조 횟수가 없으면 gc가 메모리에서 삭제”, 

“실제 데이터” 

# mutable  불별적인, immutable  가변적인의 차이

## Mutable (가변 객체)

**"바꿀 수 있는"** 객체입니다. 객체의 메모리 주소를 유지하면서 그 안에 담긴 값만 자유롭게 수정할 수 있습니다.

- **대표적인 종류:** `list`, `dict`, `set`
- **특징:** 내부의 요소를 추가, 삭제, 수정해도 객체 자체의 메모리 주소(`id`)는 변하지 않습니다.

> 예시:
> 
1. 가변적 변수의 참조 정보 

`my_list = [1, 2]   # 메모리 주소 500번에 리스트 생성
my_list.append(3)  # 500번지 그 자리에서 데이터만 [1, 2, 3]으로 확장됨 (주소 고정)`

상기에 따라 파이썬의 heap메모리 영역에 리스트 pyobject 객체정보가 헤더로 저장된다.  스택 메모리에는 변수 이름과 heap메모리의 객체를 참조하는 참조값이 담긴다. 만약  list에 새로운 값을 추가한다면 변수 이름에 가르키는 주소값은 그대로 있고, heap영역에 데이터가 직접적으로 수정되는 것이므로 변수의 참조 주소는 동일하며,  객체의 데이터 값만 수정이 된다. append는 기존 객체의 데이터만을 수정한것으로 stack에서 가르키고 있는 참조 주소가 바뀌지 않았기 때문에 그대로 유지된다

1. 가변적 변수에 + 새로운 가변 변수가 추가될때 

`my_list = my_list + [3]` 

이와 같은 코드를 작동한다면 [3]의 새로운 리스트는 다른 객체이며 heap에 저장되는 별도의 객제가 된다. 결국 이를 저장하는 변수 역시 stack에 새로운 참조 주소를 가져야만 heap의 새로운 객체를 참조하기 떄문에 결과적으로 참조 주소 값이 바뀐다.

1. 가변적 변수 이름만 바뀔시에

a = [1, 2, 3]
b = a
b.append(4)
print(a) # 결과: [1, 2, 3, 4] (a도 같이 바뀜!)

상기에 따라 파이썬의 heap메모리 영역에 리스트 객체정 보가 헤더로 저장된다.  스택 메모리에는 변수 이름과 heap메모리의 객체를 참조하는 참조값이 담긴다.  변수 이름만 다르게 한다면, stack 매모리의 매핑 정보중 변수이름이 수정되고, 참조 주소는 그대로 갇고 있는 상태이다( 파이썬 같은 고급 언어는 gc의 원할한 동작을 위해 참조 주소를 임의로 조작하는 행위를 할 수 없다.) 결국 다른 변수의 이름일지라도 heap메모리의 객체의 동일 참조주소를 가지고 있기 때문에 (동일한 참조값을 보고 있기 때문에) 객체 데이터의 직접 수정이 일어나면 heap메모리를 참조하기 있던 stack 모든 변수들이 같이 움직인다.

Immutable (불변 객체)

말 그대로 **"바꿀 수 없는"** 객체입니다. 메모리에 한 번 올라가면 그 내용을 수정할 수 없습니다. 만약 값을 바꾸려고 하면, 파이썬은 기존 객체를 수정하는 대신 **새로운 객체를 생성**하여 메모리에 할당합니다.

- **대표적인 종류:** `int`, `float`, `str`, `tuple`, `bool`
- **특징:** 값이 변하면 참조하는 메모리 주소(`id`)도 함께 변합니다.

> 예시:
> 
> 
> `a = 10       # 메모리 주소 100번에 '10' 생성
> a = a + 1    # 100번지의 10을 11로 바꾸는 게 아니라, 200번지에 '11'을 새로 만들고 a가 거기를 가리키게 함`
> 

---

정수는 불변객체로 객체자체의 수정이 불가하며, 이는 heap메모리 상의 객체의 직접 수정이 불가하다는 소리이다. 결국 heap메모리상의 객체를 수정이 불가능 할 상태에서 stack메모리의 변수의 이름을 바꿔 버리면 바뀐 변수는 같은 heap메모리의 객체를 참조하는 것이 아니라 새로운 객체를 만들어 다른 주소를 참조하게 된다.

# Call by Value