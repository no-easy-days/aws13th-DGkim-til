# 강의 git, github Cli 
- 한줄 키워드 학습 :  https://www.notion.so/ej31/12-24-2d3954dac7558081a2f5c884c490fb52?v=2cf954dac75581aa9afd000cc959191b&source=copy_link

# git 의 내역
이전에 프로젝트의 결과물의 관리는 워드,엑셀들 내부 문서로 관리하는 경향이 있었으나, '코드'는 수정이 잦고 그 단위가 미세할수도 있기에 이를 효과적으로 추적 관리하는
계념인 VCS의 계념이 탄생했다. 이중 git이 없었을때의 버전관리는 SVN 이란 중앙집중 방식의 버전관리 프로그램을 이용 하였다. 하지만 SVN시스템의 관리는 
다중 인원 협업시 이력 추적에 어려움 그리고 중복과 덮어쓰기 의 문제가 발생하였고 이에 따라 git이란 분산 관리 시스템이 떠오른다. git은 빠르고 간단하게
여러 작업의 변동 사항을 추적하는 것이 가능하게 해주었다.

- 코드의 이력을 추적 관리하는 이유는 무엇인가?(코드를 과거로 되돌릴 필요가 있을까?) = 버전관리의 이유
: 실수를 수정하는것, 각 이력(버전)의 상태를 확인 분석할때, 법적문제등으로 인하여 이전의 코드와 비교 하여 특정시점의 책임소재를 명확히 하기위함(SI회사의 문제),
expriment, rc, nightly 등 각 버전에 대한 여러 실험을 해보고 싶을때

- VSC의 특징 : 누가 언제 무엇을 변경했가를 추적 관리하는 프로그램

# git의 강점

1. 여려명이 동시에 작업 하여도 그 변동 이력을 '추적'이 가능하며, 특정 시점으로 및 특정 시점의 특정 부분으로의 '복원'이 가능하다(Cherry Picking). 
   또한 이력 추적이 가능하므로 다중 '협업'이 가능하다.  또한 각자 로컬에 분산 관리 하여 저장하기 때문에 원격저장소(Remote)의 코드가 소실되어도 '복구(백업)'가 가능하다.

- Remote : 로컬이 아닌 인터넷 환경에서 작동하는 저장소
- Git : 작업 파일들을 '분산' 관리하여 이력을 추적해주는 프로그램
- '분산' 이란 키워드는 '동시성 제어'와 '충돌'이란 키워드가 핵심
- 동시성 제어는 여러 동시 요청을 효율적으로 제어하는 방식
- 충돌은 동일 파일의 동일 부분의 코드가 충돌할때 발생

2. 원격저장소의 코드를 여러명이 '동시'에 클론이 가능하다. 네트워크가 따로 없이 클론된 코드를 로컬에서 작업이 가능하다. 원격저장소 코드시 로컬의 코드가 살아있다면복구가 가능하다(코드를 분산관리 하기때문에 가능)
   
# git의 사용

## git config
먼저 git config로 사용자의 정보를 입력하여 git을 활성화 시켜주는 것이 중요하다.
git은 다중 사용자들의 변경내역을 추적하는 만큼 해당 파일의 수정자가 누구인지 표기하는 것이 중요하기에 해당작업을 진행한다.
user.name / user.email은 커밋시 커밋 메타데이터에만 영향을 미친다. 
user.name / user.email이 github의 아이디와 이메일과 다르더라고 github에 push는 가능하나 커밋 이력이 달라 추적이 어럽다. 
그러므로 config설정시 user.name / user.email은 실제 github 아이디, 이메일과 동일시 하는것을 추천한다.

- git을 윈도우 터미널로 이용시 git bash를 이용하는것을 추천, 리눅스 기반 bash로 여러 명령어 사용가능
- 맥은 아이텀, 코스티
- git과 관련된 원격과 인증의 작업의 문제시 git config --list의 내용을 확인해 보기
- git config --globbal / --local 명령어 대부분은 global을 쓰나 일부 시스템에서 local을 쓰기도 한다.

## git init
작업 디렉토리(나의 로컬폴더)안에 git 저장소를 생성한다. 실제 디렉토리 안에 .git폴더가 추가되며 작업디렉토리의 변경사항들이 저장된다.

## git add
git은 코드변경을 자동 저장하지 않으며 의미있는 단위로 묶어 커밋이라는 과정을 거쳐야 이력이 저장된다.
git은 작업 디렉토리 - 스테이징 - 커밋이라는 과정을 거친다. 
- 작업 디렉토리는 실제 내가 코드를 수정하는 공간으로 실제 폴더의 이름을 칭한다.
- 스테이징을 내가 실제 코드를 수정한 파일을 올리는 공간으로 커밋전에 불필요한 파일을 걸러주어 커밋의 목적을 명확하게 하는 단계이다.
- 커밋은 스테이징 단계에서 의미있는 단위로 묶인 파일들의 변경 내역을 git 저장소에 저장한다.
git add는 내 작업디렉토리의 결과물을 스테이징 단계에 올리는 행위

 ### git add 시나리오 (bash상 작업 디렉토리 안의 파일을 생성하여 스테이징에 올리는 과정)
1. vim "README.md" -> README.md란 파일을 생성한다.
2. vim 을 사용시 README.md 파일의 내부를 작성할수 있으며 'I'를 사용하여 해당 내용을 수정한다
3. esc를 눌러 빠져나온후 'w' (저장), 'q'(닫기), 혹은 'wq'(저장후 닫기) 를 눌러 빠져나온다.
4. 작업 디렉토리에 README.md 파일이 생성되었으며 이를 스테이징에 올린다. 
  bash 상 git add "파일의 이름을" (git add "README.md"쓰지만, 작업 디렉토리의 모든 파일을 올릴시는 git add . 를 쓴다.

## git commit
staging에 있는 파일들의 변경 내역을 내 로컬/리모트 상에 저장 하는 행위로, 스테이징에 올라와 있는 파일을 로컬 저장소에 영구 기록 한다.
commit은 명령 실행시 작업 메세지가 필요하며 해당 파일의 어떤 부분이 수정되었는지 명확히 표기해 주는게 중요하다.

 ### git commit 시나리오 (bash상 commit 하는과정)
1. git add . 로 스테이징에 파일이 올라와있는 상황
2. git commit 명령어로 커밋 메세지 에디터로 들어가서 커밋 메세지를 칠수 있고
3. git commit -m "~~~" 으로 바로 "~~~"의 커밋 메세지를 쓸수 있다.

## git log 
git log는 나의 커밋이력을 표시해주는 명령어로 커밋이 완료될시 일정수의 해쉬값이 저장되며 해당 해쉬값을 참조한다.

## git status
git status는 내 작업 디렉토리 안의 파일들의 상황을 알려주는 명령어로 어떤 파일이 add가 되어 있는지 새로 생생된 파일이 무엇인지 알려준다.

## branch
main에서 갈라지는 독립적인 작업 공간, 파일을 실제로 복사하는 것이 아니라 이력사항을(특정 커밋) 포인팅 하고 있을뿐이다. 파일의 수정 사항이 있을시 어느 부분이 갈라졌는지만 추적한다. 
- 원본 사항에서 바꾼 이력만을 추적하며, 지워도 원본에 영향이 가지 않는다.
- 브랜치는 커밋사항을 포인팅 하는것이며 만일 main에서 바로 브랜치 생성시 생성 브랜치는 main브랜치를 포인팅 하는 것이 아니다.
  * ex:  commit b0d4ec9b414c2e4973d017bc2ec9333a9d2baf40 (HEAD -> feature/login, master)
  * 이 경우는 브랜치가 메인과 동일한 커밋사항을 포인팅 하는것이며, 현재 head가 feture브랜치를 바라 본다,
  * 브랜치에서 새로운 커밋이 일어 날경우 그 커밋으로 포인팅 한다.
- 브랜치의 변경사항을 main으로 merge할수 있으며 (로컬), 리모트일시 pr을 통해 리모트 origin에 merge가 가능
- 브랜치 생성시 이름을 feture/login, hotfix/login 으로 생성하여 "/" 로 구분을 지어주면 파싱기능에 용이하다.
  
###  git branch 
브랜치 생성 명령어, git branch -d "이름" 병합된 브랜치만 삭제 -D 병합상관없이 강제 삭제

### git switch
브랜치 이동할때 쓰는 명령어, git switch -c "브랜치이름" 일시 브랜치를 생성후 바로 이동
git checkout과의 차이 -  switch는 브랜치 전환만 가능, checkout는 브랜치, 헤드등 모두 이동 가능

## head(실습 사항은 1차 과제 확인!)
현재 내가 바라보는곳, git에서의 head는 단 한개만 존재
- head의 역할 : 현재의 브랜치를 추적하는것, head가 브랜치를 경유하지 않고 커밋을 바라보고 있으면 고아 객체가 발생
- head를 확인하는법 (1차과제에 자세내용 참조)
* git blanch로 *모양의 브랜치가 현재의 head모양
* git log로 확인
* cat .git/HEAD
- head의 상대참조 : HEAD~숫자
- 고아 객체 (도달불능 헤드 Detached HEAD) : 헤드가 브랜치를 바라보지 않고 특정 커밋을 바라보는것, 해당 상태에서 새로운 커밋을 추가하고, 어떠한 브랜치로 이동하면 head가 해당 브랜치로 이동해버리며 그 브랜치는 이전에 커밋을 가르키지 않으므로, 추가되었던 커밋은 어떠한 참조 정보가 없으며 도달 불능의 상태가 된다. 이를 방지 하기 위해서는 고아 객체 상태의 헤드에서 커밋이 생성시 브랜치를 반드시 생성에서 참조 할수 있는 정보를 만드는 것이 중요하다.
  
## branch strategy
브랜치 전략, 팀이 효율적으로 코드 작업을 위하여 브랜치의 전략을 정하여 사용하며 합칠지에 대한 규약

### git flow strategy
체계적인 브랜치 전략으로 릴리즈 주기가 긴 회사에서 주로사용, 브랜치 간의 책임이 정확하게 분산
- master브랜치에서 develop으로 분화한다. master는 product로 칭하며, devlop은 beta로 칭한다.
- 특정 기능 개발시 feture브랜치로 만들어 작업하고 작업 결과를 devlop에 merge한다.
- devlop에 merge된 기능을 release 브랜치로 붙여 한번더 검토하여 master로 붙일 수 있고, 바로 master로 붙일수 있다.
- release 브랜치를 따로 운영하는 전략은 (배포전 최종 검토 과정이 필요한 대형 서비스)
- hotfix 브랜치는 master에서 바로 갈라지며 작업후 바로 master로 올리는 것이 가능 (product에 긴급한 문제가 발생했을때 바로 수정이 필요할떄)
- 브랜치들의 작업이 master로 머징될때 마다 '태깅' 작업이라는 버전을 붙여서 이력을 관리한다.

### github flow strategy
단순하고 빠른 브랜치 전략, 큰 전략이 필요없는 소규모 회사 및 시니어 중심으로 빠른 배포를 중심으로하는 회사애서 주로 사용
- 메인 브랜치에서 dev브랜치를 쓰지 않고 바로 feture 브랜치로 기능 개발후 테스트후 main으로 붙인다.
- main으로 바로 머지됨으로 feture 브랜치의 테스트가 매우 중요!

## git merge 
두개의 브랜치를 하나로 합치는 작업
여러 merge 방식의 요약 (링크 : https://jangjjolkit.tistory.com/49, https://jtm0609.tistory.com/185)

### fast-forward
main브랜치에서 feture 브랜치로 switch후 메인브랜치는 커밋내역이 없으며 feture에서 새로운 커밋이 발생 할시 main이 새로운 커밋에서 최신 커밋의 변경사항으로 이동한다. feture 브랜치의 커밋들을 하나하나 추적하는 것이 아니라 최신 커밋을 포인팅 하는것 뿐

### 3-way
브랜치가 갈라졌을시(브랜치가 갈라지는 기준은 두 브랜치 간의 서로 다른 커밋이 발생했을때)
main브랜치에서 feture브랜치를 생성한 후 feture의 커밋이 일어났으며 이전에 main에도 커밋이 일어났을 경우  git은 기존 커밋에서 main의 커밋과 , feture의 커밋 까지 3개를 비교하여 새로운 병합 커밋을 생성한다.

### 기타 merge방식 
- rebase : 브랜치 히스토리를 한줄로 합치는 작업
- Squash : 브랜치의 모든 커밋 작업물을 하나로 압축하여 main에 머징하는 방식

## conflict
두개의 브랜치가 같은 파일의 같은 줄을 수정했을시 이를 병합하려 했을때 발생하는 상황
- conflict시 merging 스테이지 단계로 이동하며 충돌파일의 수정후 새로운 커밋이 발생하면 다시 돌아옴
-  <<< === >>> , === 구분으로 <<<는 이전 커밋, >>> 는 병합하려는 커밋
- conflict시 수정시 상기 사항을 수정하지 않고 그대로 커밋해 버리면 << == >> 이 포함된 상태로 바로 커밋되어 버림

## git remote
remote 저장소는 원격 클라우드로 존재하는 git 저장소, git remote 명령어는 브랜치에 업로드 경로를 지정해 주는것
원격저장소는 github, gitlab,bitbucket 등이 있으며, github, gitlab으로 스탠드얼론 버전으로 도커환경으로 구축가능 

- git remote add 원격저장소이름 http~
  * 원격저장소 이름은 임의로 지정이 가능하나 origin이 표준
- 로컬에서 원격저장소로 remote시 리모트 사이트의 레포지토리에는 어떠한 커밋 로그가 없는 상태여야함(커밋내역이 있으면 로컬에서 바로 push가 안된다)
- 원격저장소의 이름을 달리하여 github, gitlab에 업로드할 위치를 다르게 지정할수 있다.

## git push
로컬의 코드를 원격저장소로 밀어 올리는것 
- git push --set--upstream origin mater 로컬에 원격저장소 push 위치를 지정하는법 (origin이름의 원격저장소에 master브랜치에 올리는것, git push -u origin mater 사용가능)
- git push 가 안될시에는
  * 원격 저장소에서 먼저 커밋이 일어날시에는 로컬에서 push가 안된다. 먼저 pull로 원격 레포의 커밋을 가져오고 '충돌'시에는 이를 해결하고 커밋후 다시 push해야됨
- 강제 push(force push)는 로컬의 커밋을 레포로 강제로 올리는 기능으로 원격지 중요 브랜치는 룰 기능으로 막을수도 있다 (협업시는 협의없이 절대 금지!!)
  
## git pull
원격 저장소의 코드를 로컬로 받아 오는것
- git pull은 git fetch와 git merge의 기능을 한번에 수행하는것
- git fetch는 원격저장소의 최신 변경사항을 확인하여 log에 기록만 하고, merge는 해당 변경사항을 병합하는 행위
- pull은 fetch된 변경사항 merge되는 행위

## fork / colne
fork는 레포지토리를 복제하는 작업으로 fork로 레포를 내 레포로 복제후 작업하고 원본에 pr로 붙일수 있음, clone은 레포를 로컬로 클론한것으로 원격지의 권한이 없을시 push가 안되서 pr이 불가 할수 있다.

## issue 
코드에 문제가 생길시 제기하는것, github에서 작성된 이슈를 브랜치로 만들어 로컬로 클론후 pr로 올려서 main으로 머지

## pull request (pr)
- 브랜치에서 작업후 origin main으로 머지하기 전에 검토 요청을 하는 작업
- 원격 저장소에서 conflict 진행후 merge 되면 origin에 main에 머지되며 로컬은 pull을 통해 최신화 함 

# github Cli
githib의 공식 명령줄 도구, 브라우저에서 터미널로 여러 작업환경으로 이동시 맥락이 전환되어 업무 효율이 떨어질수 있음, 터미널상에서 github의 여러 동적활동을 터미널로 작업가능하다. 또한 터미널 명령어로 자동화도 가능하다. gh 명령어로 사용가능

## gh auth 
github인증 기능을 이용할수 있게 해준다.

- gh auth login : 로그인 인증을 가능하게 해준다. 
- gh auth status : 나의 인증 상태를 표시한다. 자동화시 active account 상태로 로그인 체크가 가능하다.

## gh repo 
레포지토리관련 명령어 
- gh repo create 원격레포를 터미널로 생성해준다. 
- gh repo fork 레포를 fork 할때 사용
- gh repo view 레포 정보 확인
- gh repo edit 디스크립션 바꾸는 명령어, 레포를 터미널상 자체로 수정하는 행위는 지양할것, 일괄적 자동화 작업을 위해서 일부 사용

## gh secret
각종 secret키를 관리하는 명령어, 귀중한 키는 github로 올릴시 secret로 생성하여 올려야한다. 조회시 시크릿의 값을 알수없다.
- '<' 명령어는 오른쪽값을 왼쪽으로 집어넣는것(오버라이팅으로 이전값을 삭제한다), '<<'은 여러값을 누적해서 넣는다 
- '>' 명령어는 왼쪽값을 오른쪽에 집어넣는것(오버라이팅으로 이전값을 삭제한다), '>>'은 여러값을 누적해서 넣는다. 









