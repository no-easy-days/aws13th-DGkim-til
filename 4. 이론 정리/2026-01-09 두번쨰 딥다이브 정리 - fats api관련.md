# 3주차 딥다이브 주제

세마포아?, 언터럽트?



<aside>
<img src="notion://custom_emoji/845a6cfa-ad4b-4505-8350-960c9f51a87a/168954da-c755-8023-8dcf-007afaa4b2e6" alt="notion://custom_emoji/845a6cfa-ad4b-4505-8350-960c9f51a87a/168954da-c755-8023-8dcf-007afaa4b2e6" width="40px" />

제가 적어놓은 건 가이드에 불과하며 딱 적혀있는 것만 조사하시면 안됩니다.
본인만의 자료 조사 후 정리 방법, 그리고 발표 스타일을 확실하게 가져간다는 목표로 진행하셔야 합니다!

</aside>

### 1. 데이터 유효성 검사(Validation)와 직렬화(Serialization) → Pydantic

**관련 주제 힌트:** Python Type Hint(타입 힌트), JSON 구조, 데이터 무결성, 스키마(Schema)

**조사 할 때 신경쓰면 좋은 것**

- 회원가입 폼에서 이메일 주소 칸에 '안녕하세요'라고 적으면 서버 내부에서는 어떤 일이 벌어질까?
- 데이터가 서버 로직(함수) 안으로 들어오기 *전에* 문지기가 막아주는 것과, 들어와서 에러가 나는 것의 차이는?
- FastAPI의 단짝 친구인 **Pydantic**은 어떻게 파이썬의 타입 힌트(`age: int`)만 보고 검사 코드를 자동으로 만들어주는가?

**제프 의견**

- 들어오는 데이터가 깨끗하다고 믿는 순간 시스템은 망가집니다.
과거에는 개발자가 `if type(age) != int:` 같은 코드를 수십 줄씩 짰습니다.
Pydantic을 사용한다면 어떻게 코드가 바뀌게 될까요? 실제로 사용해보고 발표해봅니다.

---

### 2. 인증과 토큰 (Authentication & Token)

**관련 주제 힌트:** Stateless(무상태), 쿠키(Cookie) vs 세션(Session), JWT(JSON Web Token), Authorization Header

**조사 할 때 신경쓰면 좋은 것**

- HTTP는 금붕어 기억력(Stateless)이라고 합니다. 그럼 로그인을 했다는 사실을 서버는 어떻게 계속 기억할까요?
- 서버가 장부를 가지고 대조하는 방식(세션)과, 손님에게 도장 찍힌 티켓을 주는 방식(토큰/JWT)의 장단점은?
- JWT라는 긴 문자열을 복호화(Decode)하면 그 안에 내 아이디가 들어있다는 게 사실인가? (토큰 뜯어보기)

**제프 의견**
"로그인 기능 만들어주세요"는 쉬워 보이지만 보안의 핵심입니다.
그리매번 요청할 때마다 "저 아까 로그인한 철수인데요"라고 증명하는 과정이 필요합니다.
놀이공원 자유이용권(= 인증 토큰)을 보여주기만 하면 놀이기구(= 인증통과 후에만 사용가능한 API)를 탈 수 있는 원리를 이해해 봅니다.
더 나아가서 간단하게 샘플까지 만들어봅시다

---

### 3. 의존성 주입 (Dependency Injection, DI) → 코드를 부품 조립하듯이?

- **관련 주제 힌트**
    - 결합도(Coupling), 제어의 역전(IoC), "Code Reusability", 객체 지향 설계(SOLID)
- **조사 할 때 신경쓰면 좋은 것**
    - DI를 쓸때와 안쓸때의 차이는?
        - 요리사가 요리할 때마다 직접 밭에 가서 배추를 뽑아오는 식당(강한 결합) vs
        전문 납품업자가 아침마다 신선한 배추를 주방에 넣어주는 식당(의존성 주입)의 효율성 차이는?
        - 스마트폰을 만들 때 배터리를 본체에 납땜해서 붙여버리는 것(일체형) vs
        교체 가능하게 소켓으로 만드는 것(주입 가능)은 수리할 때 어떤 차이가 있을까요?
    - **내가 필요한 도구를 직접 만들지 않고, 누군가에게 '이거 줘!'라고 요청만 하면 알아서 가져다주는 시스템**이 어떻게 코드를 깔끔하게 만든다는 걸까요?
- **제프 의견**
    - 초급 개발자와 중급 개발자를 나누는 기준이 되는 아주 중요한 설계 패턴입니다!
    - 이 개념을 모르면 코드가 **필연적으로!!** 스파게티처럼 엉키게 되고 제대로 알게 된다면 레고 블록처럼 깔끔하게 조립할 수 있습니다.
    - FastAPI는 '의존성 주입'을 전 세계에서 가장 쉽고 직관적으로 구현해 냈다는 평가도 받고 있습니다.

---

### 4. ORM (Object Relational Mapping)

**관련 주제 힌트:** SQL, RDBMS(관계형 데이터베이스), 테이블(Table) vs 객체(Object), SQLAlchemy

**조사 할 때 신경쓰면 좋은 것**

- 데이터베이스는 엑셀처럼 표(Table)로 되어 있고, 파이썬은 객체(Object)로 되어 있습니다. 이 모양 차이를 어떻게 극복할까요?
- `SELECT * FROM users WHERE name = 'Jeff'` (SQL) 대신 `db.query(User).filter(User.name == 'Jeff').first()` (Python) 처럼 쓰는 이유는?
- ORM을 쓰면 나중에 데이터베이스 프로그램(DB 엔진)을 바꿔도 코드를 안 고쳐도 된다는데 진짜일까?

**제프 의견**

데이터베이스는 엑셀처럼 행과 열로 되어 있고, 파이썬은 객체(Object)로 되어 있습니다. 이 둘은 모양이 달라서 서로 대화하기 힘듭니다.
이러한 패러다임의 차이를 극복하기 위해 ORM이 등장했습니다.
이걸 도입하면 어떤 장점과 단점이 있을까요? 정확하게 트레이드오프는 무엇이 있고 실제로 사용해보면서 함께 자세히 분석해봅시다!

ps. 만약 DB를 쓰신다면 설치없이 바로 사용가능한 `sqlite`를 사용하시기 바랍니다.

---

### 5. ASGI와 비동기(Async) 처리

**관련 주제 힌트:** 동기(Sync) vs 비동기(Async), Blocking I/O, Event Loop, Uvicorn, `async` / `await`

**조사 할 때 신경쓰면 좋은 것**

- Python은 원래 느리다고 하는데 FastAPI는 어떻게 Node.js나 Go만큼 빠를 수 있는가? (키워드: ASGI)
- Django나 Flask 같은 먼저 출시된 프레임워크와 달리 FastAPI는 왜 ASGI(비동기 게이트웨이)를 채택해서 속도 혁명을 일으켰는가?

**제프 의견**
처음이라면 어려운 주제지만 이게 **FastAPI를 쓰는 진짜 이유랍니다. 🤖**
단순히 "빠르다"가 아니라 "기다리는 시간을 효율적으로 쓴다"는 개념이지요.
이 원리를 정확하게 이해하시면 서버가 적은 컴퓨터 자원으로도 수만 명의 접속자를 감당할 수 있게 된다는 걸 확실하게 알게 됩니다!






# 1번

# 2번(양세윤)

# 3. 의존성 주입 (Dependency Injection, DI) → 코드를 부품 조립하듯이? (김동균)

- **관련 주제 힌트**
    - 결합도(Coupling), 제어의 역전(IoC), "Code Reusability", 객체 지향 설계(SOLID)
- **조사 할 때 신경쓰면 좋은 것**
    - DI를 쓸때와 안쓸때의 차이는?
        - 요리사가 요리할 때마다 직접 밭에 가서 배추를 뽑아오는 식당(강한 결합) vs
        전문 납품업자가 아침마다 신선한 배추를 주방에 넣어주는 식당(의존성 주입)의 효율성 차이는?
        - 스마트폰을 만들 때 배터리를 본체에 납땜해서 붙여버리는 것(일체형) vs
        교체 가능하게 소켓으로 만드는 것(주입 가능)은 수리할 때 어떤 차이가 있을까요?
    - **내가 필요한 도구를 직접 만들지 않고, 누군가에게 '이거 줘!'라고 요청만 하면 알아서 가져다주는 시스템**이 어떻게 코드를 깔끔하게 만든다는 걸까요?
- **제프 의견**
    - 초급 개발자와 중급 개발자를 나누는 기준이 되는 아주 중요한 설계 패턴입니다!
    - 이 개념을 모르면 코드가 **필연적으로!!** 스파게티처럼 엉키게 되고 제대로 알게 된다면 레고 블록처럼 깔끔하게 조립할 수 있습니다.
    - FastAPI는 '의존성 주입'을 전 세계에서 가장 쉽고 직관적으로 구현해 냈다는 평가도 받고 있습니다.

### **3. 의존성 주입 (Dependency Injection, DI) → 코드를 부품 조립하듯이? (김동균)**

- **관련 주제 힌트**
    - 결합도(Coupling), 제어의 역전(IoC), "Code Reusability", 객체 지향 설계(SOLID)
- **조사 할 때 신경쓰면 좋은 것**
    - DI를 쓸때와 안쓸때의 차이는?
        - 요리사가 요리할 때마다 직접 밭에 가서 배추를 뽑아오는 식당(강한 결합) vs 전문 납품업자가 아침마다 신선한 배추를 주방에 넣어주는 식당(의존성 주입)의 효율성 차이는?
        - 스마트폰을 만들 때 배터리를 본체에 납땜해서 붙여버리는 것(일체형) vs 교체 가능하게 소켓으로 만드는 것(주입 가능)은 수리할 때 어떤 차이가 있을까요?
    - **내가 필요한 도구를 직접 만들지 않고, 누군가에게 '이거 줘!'라고 요청만 하면 알아서 가져다주는 시스템**이 어떻게 코드를 깔끔하게 만든다는 걸까요?
- **제프 의견**
    - 초급 개발자와 중급 개발자를 나누는 기준이 되는 아주 중요한 설계 패턴입니다!
    - 이 개념을 모르면 코드가 **필연적으로!!** 스파게티처럼 엉키게 되고 제대로 알게 된다면 레고 블록처럼 깔끔하게 조립할 수 있습니다.
    - FastAPI는 '의존성 주입'을 전 세계에서 가장 쉽고 직관적으로 구현해 냈다는 평가도 받고 있습니다.

## **3-1 의존성 주입이란 무엇인가? (용어 설명)**

의존성 주입(Dependency Injection, DI)이란

객체가 스스로 필요한 객체를 직접 생성하는 것이 아니라,

외부에서 생성된 객체를 전달받아 사용하는 설계 패턴이다.

이는 객체의 **생성과 사용의 관심사를 분리**하는 것이며,

현대 객체 지향 프로그래밍의 핵심 가치를 담고 있다.

비유하자면 요리사가 직접 농사를 짓는 것이 아니라

외부 업체로부터 손질된 재료를 공급받아 요리에만 집중하는 것과 같다

## **3-2 DI의 역사**

### **전통적 프로그래밍 방식(java,c++)**

1960년대 부터 OOP의 개념이 대두, 1980년대 c++, 1990년대 java로 OOP의 표준이 잡힘, 초기 OOP의 핵심 가치는 객체가 자신의 책임을 다하도록 설계한다는 것으로 객체가 자신의 책임 한계에 따라 연결되며 이에 따라 결합도가 생기게 된다. DI의 개념이 대두되기 전의 전통적 프로그래밍 방식에서는 결합도의 정도에 따라 코드의 방식이 달라졌다.

결합도(Coupling) - 한 모듈(클래스가) 다른 모듈에 얼마만큼 의지하는가를 나타내는 지표

### **강한 결합**

한개의 모듈(클래스)이 '강한 결합'을 가지고 있을 경우는, 보통 클래스 내부에서 다른 클래스를 **직접 생성(new)** 하여 코드를 실행한다.

강한 결합 (Tight Coupling): 두 클래스가 너무 친해서 하나가 바뀌면 다른 하나도 무조건 바꿔야 하는 상태입니다. (마치 샴쌍둥이처럼 분리가 불가능한 상태)

```
class BenzEngine {
    void start() { System.out.println("벤츠 엔진 가동!"); }
}

class Car {
    private BenzEngine engine;

    public Car() {
        // Car가 직접 BenzEngine을 선택하고 생성함 (강한 결합)
        this.engine = new BenzEngine();
    }

    public void drive() {
        engine.start();
    }
}
```

하지만 강한결합의 문제점 : 이는 코드가 서로 꽉 맞물려 있어 하나를 바꾸면 전체가 깨지는 문제를 야기

1. 교체 불가: Car는 BenzEngine에 묶여 있습니다. 만약 BMWEngine으로 바꾸고 싶다면 Car 클래스의 소스 코드를 직접 수정해야 합니다.
2. 테스트 곤란: BenzEngine이 만약 1억 원짜리 장비와 연결되어야만 작동하는 코드라면, 단순한 Car 테스트를 위해 매번 그 장비를 가동해야 합니다.
3. 확장성 저하: 새로운 엔진이 나올 때마다 Car 클래스를 계속 건드려야 하므로 버그가 생길 확률이 높습니다.

결국 강한 결합의 문제를 깨트리기 위해서 느슨한 결합의 이론이 대두되었다.

### **그렇다면 강한 결합은 객체 지향이 아닌가?**

아니다.

객체지향 프로그래밍의 원칙에 위배될뿐, 강한 결합도 엄연히 객체지향적인 속성을 일부 가지고 있다. 객채지향은(캡슐화, 상속, 다형성, 추상화) 4가지의 속성을 가지고 있으며 강한 결합은 이중 캡슐화와 상속을 달성하지만 다형성, 추상화과 무력화 된다.

달성한 것 (또는 유지 가능한 것) 

① 캡슐화 (Encapsulation) - 절반의 성공 강한 결합 상태에서도 private 키워드를 써서 내부 데이터를 숨기고 메서드를 통해 소통할 수 있습니다.

성공: 객체 내부의 복잡한 로직을 감추는 데는 문제가 없습니다. 한계: 하지만 "이 클래스가 어떤 다른 클래스를 사용하는지"에 대한 정보(의존성)는 감추지 못하고 외부에 노출되거나 코드에 박히게 됩니다.

② 상속 (Inheritance) - 달성 가능 강한 결합이라고 해서 상속을 못 하는 것은 아닙니다. A 클래스가 B를 상속받는 구조는 결합도와 상관없이 문법적으로 완벽히 작동합니다.

성공: 부모의 기능을 물려받아 재사용하는 것 자체는 가능합니다.

제대로 달성하지 못한 것 (가장 치명적인 부분) 

③ 다형성 (Polymorphism) - 무력화됨 다형성의 핵심은 **"하나의 인터페이스로 여러 구현체를 갈아 끼울 수 있다"**는 것입니다.

실패 이유: 강한 결합은 코드에 new BenzEngine()처럼 특정 클래스를 못 박아버립니다. 실행 시점에 다른 객체(예: BmwEngine)로 교체하는 것이 불가능해지므로, 다형성이 주는 '교체 가능성'의 이점을 전혀 누릴 수 없습니다.

④ 추상화 (Abstraction) - 의미가 퇴색됨 추상화는 "무엇을 하는지(What)"만 보여주고 "어떻게 하는지(How)"는 감추는 것입니다.

실패 이유: 강한 결합은 상위 클래스가 하위 클래스의 구체적인 존재를 너무 잘 알고 있는 상태입니다. 추상적인 인터페이스만 바라봐야 하는데, 실제 구현체(구체 클래스)에 직접 매달려 있기 때문에 추상화라는 벽이 무너진 셈입니다.

### **느슨한 결합**

한개의 모듈(클래스)이 느슨한 결합을 가지고 있을경우는 **인터페이스(Interface)** 라는 것을 통하여 코드들의 결합을 약화시키고 **팩토리 패턴** 이라는 곳에서 아예 객체 생산을 맡기는 과정으로 한개의 클래스 내부에 객체를 직접 생성하는 과정을 막았다.

느슨한 결합 (Loose Coupling): 서로의 내부 구현을 몰라도 약속된 방식(인터페이스)으로만 대화하는 상태입니다. (마치 USB 포트처럼 어떤 장치든 꽂으면 작동하는 상태) 팩토리 패턴 (Factory Pattern) : new를 직접 하기 싫어서, 객체 생성을 전담하는 '공장(Factory)' 클래스를 만들었습니다.

하지만 이러한 느슨한 결합에서도 인터페이스 방식은 역시 인터페이스를 받아서 new라는 객체를 생성해서 사용하여야 했고, 팩토리 패턴 역시 객체의 직접 생산은 막을 수 있지만 오히려 '팩토리'라는 특수한 목적의 클래스가 하나 더 생기므로서 새로운 의존도가 발생해버린다.

### **IoC 개념의 등장**

결국 전통적 프로그래밍 방식인 개발자 본인이 주체가 되어서 코드 내에서 의존성을 해결하려는 방식은 불가능에 가까웠고 IoC 개념이 대두 되기 시작한다.

제어의 역전(Inversion of Control, IoC) : 프로그램의 제어 흐름을 개발자가 아닌 외부 프레임워크나 컨테이너가 담당하도록 하는 소프트웨어 디자인 원칙

개발자는 쌓이는 코드들의 의존성 문제를 본인의 코드 내에서 수정하기가 어려웠고, 이 문제는 개발자가 프로그램 관리의 부담이 발생하였다는 의미가 되며 , 개발자는 결국 프로그램의 제어의 주체를 다른곳에 이전 시키므로서(역전) 자신의 부담을 줄이는 방향을 선택하게 된다. 개발자는 코드 구조의 직접적 관리의 부담에서 벗어나 비즈니스 로직 에만 집중할 수 있게 되었다.

### **DI이론 대두**

ioc의 개념이 대두되고, 개발자들은 각자 다른 ioc표준을 만들어 왔으며, 2004년 마틴 파울러(Martin Fowler)라는 프로그래머가 기존의 여러 ioc 개념들을 정리하여 '객체를 외부에서 주입해주는 모든 행위'  라는 ‘의존성 주입(DI)’ 개념을 만들었다.  이후 DI는 IoC 달성을 위한 표준으로 프레임워크에 필수 요소가 되었다

### **DI가 IoC인가?**

아니다.

 DI가 IoC와 완벽하게 동일시 되지는 않는다. IoC는 객체의 생성을 내가 아닌 외부에 맡기는 프로그래밍 원칙일 뿐 DI는 IoC를 효율적으로 달성하는 도구일 뿐이다.  IoC를 달성하기 위하여 여러 방식이 있다.

1. 서비스 로케이터 (Service Locator) 패턴

DI와 가장 자주 비교되는 방식입니다. DI가 외부에서 의존성을 **주입(Push)**해주는 방식이라면, 서비스 로케이터는 객체가 직접 필요한 서비스를 **찾아서(Pull)** 가져오는 방식입니다.

- **작동 방식:** 중앙 저장소(Locator)에 서비스 객체들을 등록해두고, 필요한 객체가 로케이터에게 "A 서비스 좀 줄래?"라고 요청해서 사용합니다.
- **IoC인 이유:** 객체가 스스로 서비스를 생성하지 않고, 로케이터라는 '제3자'가 관리하는 객체를 받아쓰기 때문에 제어권이 역전된 것입니다.
- **DI와의 차이:** DI는 생성자나 메서드를 통해 '강제로' 받지만, 서비스 로케이터는 객체 내부에서 로케이터를 직접 호출합니다.

---

2. 템플릿 메소드 (Template Method) 패턴

프레임워크의 기초가 되는 디자인 패턴입니다.

- **작동 방식:** 상위 클래스에서 전체적인 흐름(알고리즘의 뼈대)을 정의하고, 구체적인 단계는 하위 클래스에서 구현하도록 비워둡니다.
- **IoC인 이유:** 하위 클래스(내가 짠 코드)가 언제 실행될지를 결정하는 것은 상위 클래스(프레임워크)입니다. 즉, 프로그램의 실행 흐름(Control)을 상위 클래스가 쥐고 있습니다.
- **예시:** "로그인 프로세스"라는 뼈대를 프레임워크가 만들고, 개발자는 그중 "DB에서 비번 확인" 부분만 코딩하면 프레임워크가 적절한 타이밍에 그 코드를 호출합니다.

---

3. 이벤트 주도 프로그래밍 (Event-Driven Programming)

주로 GUI나 웹 브라우저 자바스크립트에서 많이 볼 수 있는 방식입니다.

- **작동 방식:** 특정 이벤트(클릭, 키 입력 등)가 발생했을 때 실행될 코드(리스너/핸들러)를 미리 등록해둡니다.
- **IoC인 이유:** 내 코드가 언제 실행될지 내가 결정하지 않습니다. 사용자가 버튼을 클릭하는 순간, 시스템이나 브라우저가 내 코드를 호출(Callback)합니다. 이것 역시 제어권이 시스템에 있는 IoC의 한 형태입니다.

---

1. 팩토리 (Factory) 패턴

객체 생성의 제어권을 전문 공장(Factory) 클래스에 넘기는 방식입니다.

- **작동 방식:** 객체를 직접 `new` 키워드로 만들지 않고, 팩토리 객체에 "A 타입 객체 하나 만들어줘"라고 요청합니다.
- **IoC인 이유:** 구체적인 객체 생성 로직과 결정권을 팩토리가 가져가기 때문입니다.

### **DI가 있으면 느슨한 결합은 필요 없는가?**

아니다

DI(의존성 주입)를 쓰면 '강한 결합'이 없어지고 '느슨한 결합'이 비로소 완성되는 것입니다.

## **3-3 객체 지향 프로그래밍의 원칙**

객체 지향 프로그래밍 원칙 = 객체 지향(캡슐화, 상속, 다형성, 추상화)을 최대한 지키기 위한 프로그래밍 원칙

1. S: 단일 책임 원칙 (Single Responsibility Principle) "한 클래스는 하나의 책임(이유)만 가져야 한다."

설명: 클래스가 너무 많은 일을 하면, 그중 하나의 기능을 수정할 때 상관없는 다른 기능까지 망가질 위험이 큽니다.

비유: '청소도 하고 요리도 하고 빨래도 하는 로봇'보다는 '청소 로봇', '요리 로봇'을 따로 두는 것이 관리가 쉽습니다.

1. O: 개방-폐쇄 원칙 (Open-Closed Principle) "확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다."

설명: 기존의 코드를 변경하지 않으면서도 기능을 추가할 수 있어야 합니다. 이를 위해 보통 인터페이스를 사용합니다.

비유: 컴퓨터에 새 마우스를 연결할 때 컴퓨터 본체를 뜯어서 납땜할 필요가 없죠? USB 포트(인터페이스)가 있기 때문입니다.

1. L: 리스코프 치환 원칙 (Liskov Substitution Principle) "자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다."

설명: 부모 클래스를 사용하는 위치에 자식 클래스를 대신 넣어도 프로그램이 의도대로 동작해야 한다는 원칙입니다. 상속 관계를 올바르게 설정하는 기준이 됩니다.

비유: '자동차'를 상속받은 '전기차'는 적어도 '엑셀을 밟으면 앞으로 간다'는 자동차의 기본 기대를 저버려선 안 됩니다.

1. I: 인터페이스 분리 원칙 (Interface Segregation Principle) "자신이 사용하지 않는 메서드에 의존하도록 강제해서는 안 된다."

설명: 커다란 인터페이스 하나보다는, 구체적인 여러 개의 인터페이스가 낫습니다. 사용하지도 않는 기능이 포함된 인터페이스를 억지로 구현하게 하지 말라는 뜻입니다.

비유: 스마트폰 인터페이스에 '팩스 보내기' 버튼이 있으면 안 쓰는 사람에겐 방해만 됩니다. 전화, 카메라 등으로 기능을 쪼개야 합니다.

1. D: 의존 역전 원칙 (Dependency Inversion Principle) "구체적인 것에 의존하지 말고, 추상적인 것에 의존하라."

설명: 변화하기 쉬운 것(상세 클래스)보다는 변화하지 않는 것(인터페이스/추상 클래스)에 의존해야 한다는 원칙입니다.

비유: 전등을 켤 때 '벽 안의 구리 배선'을 직접 건드리는 게 아니라 '스위치(인터페이스)'라는 추상적인 도구에 의존하는 것과 같습니다.

## **3-4 강한 결합은 객체 지향 프로그래밍 원칙을 지키는가?**

아니다.

1. DIP (의존 역전 원칙) 위반 "상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다."

강한 결합은 이 원칙을 정반대로 수행합니다.

강한 결합: Car(상위)가 BenzEngine(하위/구체 클래스)을 직접 new 하여 의존합니다.

문제: 하위 모듈(BenzEngine)이 바뀌면 상위 모듈(Car)도 줄줄이 비엔나처럼 바뀌어야 합니다. 이는 "상위 수준의 보석이 하위 수준의 흙탕물에 박혀있는 꼴"이 됩니다.

1. OCP (개방-폐쇄 원칙) 위반 "확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다."

강한 결합의 코드는 새로운 기능을 추가(확장)할 때 반드시 기존 코드를 수정해야만 합니다.

강한 결합: 엔진을 바꾸고 싶을 때 Car 클래스의 소스 코드를 열어서 수정해야 합니다. (수정에 닫혀 있지 않음)

이상적인 설계: Car는 그대로 두고, 외부에서 새로운 엔진 부품만 갈아 끼우면 기능이 확장되어야 합니다. 강한 결합은 이 '플러그인' 같은 유연성을 원천 차단합니다.

1. SRP (단일 책임 원칙) 위반 강한 결합을 가진 객체는 보통 "자신의 원래 업무" 외에 **"의존성을 생성하고 관리하는 업무"**까지 떠맡게 됩니다.

예: Car 클래스는 '달리는' 역할만 해야 하는데, '어떤 엔진을 주문해서 조립할지'까지 결정하고 있습니다. 책임이 너무 많아지는 것이죠.

## **3-5 현대 객체 지향 프로그래밍의 핵심**

**'변화에 대한 유연성'**

파급력의 최소화 : 소프트웨어는 끊임없이 변합니다. 데이터베이스가 바뀌고, 정책이 변하고, 새로운 기능이 추가된다. OOP의 핵심은 부품화가 체계적으로 이루어 져서 유연하게 갈아껴도(유연성), 기존의 체계를 무너뜨리지 않고 무한히 확장하며(확장성), 만들어 놓은 부품을 다른 기능에 추가할 수도 있는것(재사용성)

왜 코드를 부품처럼 조립해야 할까? 전통적인 '통짜 코드(Monolithic)' 방식에 비해 부품화된 코드는 다음과 같은 압도적인 장점이 있습니다.

① 유지보수의 혁명 (Easy Maintenance) 만약 자동차가 통째로 한 덩어리라면, 타이어 하나가 펑크 났을 때 차 전체를 새로 사거나 녹여서 다시 만들어야 합니다. 하지만 부품화되어 있다면 문제 있는 그 부품만 빼서 수리하거나 교체하면 끝납니다.

② 생산성 향상과 재사용 (Reusability) 한 번 잘 만들어둔 '로그인 부품'이나 '결제 부품'은 A 프로젝트에서 쓰고, 그대로 가져와 B 프로젝트에서도 쓸 수 있습니다. 매번 바닥부터 새로 코딩할 필요가 없어 개발 속도가 비약적으로 빨라집니다.

③ 테스트와 검증의 용이성 (Testability) 전체 시스템을 가동하지 않고도, 부품 하나만 떼어내서 제대로 작동하는지 시험해 볼 수 있습니다. 엔진이 잘 돌아가는지 테스트하기 위해 차 전체를 조립할 필요 없이, 엔진 테스트기에만 걸어보면 되는 것과 같습니다.

④ 협업의 효율성 (Parallel Development) "나는 엔진 만들 테니, 너는 오디오 시스템을 만들어줘"라고 역할을 명확히 나눌 수 있습니다. 각자 만든 부품을 마지막에 조립만 하면 되기 때문에 수십, 수백 명의 개발자가 동시에 한 프로젝트를 진행할 수 있습니다.

## **3-6 DI와 OOP의 가치**

1. '생성과 사용의 분리'란 무엇인가? 전통적인 방식에서는 한 객체가 두 가지 일을 동시에 했습니다.

생성: "어떤 부품(클래스)이 필요할지 결정하고 직접 만든다(new)." 

사용: "만들어진 부품의 메서드를 호출해서 내 비즈니스 로직을 수행한다."

- *DI(의존성 주입)**는 이 두 역할을 완전히 쪼개버립니다.

사용자(객체): "나는 이 부품이 어떻게 만들어지는지, 어떤 구체적인 모델인지 관심 없어. 그냥 내 손에 쥐여주면 나는 사용만 할게." 생성자(DI 컨테이너/프레임워크): "객체들이 서로 어떻게 연결될지 설계도를 보고 내가 직접 생성해서 배달해 줄게."

1. 왜 이것이 OOP의 핵심 가치와 연결되는가? 이 분리는 단순한 역할 분담을 넘어 OOP의 궁극적인 목표인 **'유연성'**과 **'확장성'**을 완성합니다.

① 단일 책임 원칙 (SRP)의 완성 객체가 직접 다른 객체를 생성(new)한다는 것은, 그 객체가 '자기 본연의 기능' 외에 **'시스템 전체의 조립 구조'**까지 알고 있어야 한다는 뜻입니다. 연결: 생성을 외부로 넘기면 객체는 오직 자신의 비즈니스 로직(사용)에만 집중할 수 있습니다. 즉, **"클래스는 단 하나의 책임만 가져야 한다"**는 SRP를 가장 순수하게 지키게 됩니다.

② 개방-폐쇄 원칙 (OCP)의 실현 새로운 기능을 추가하거나 부품을 바꿀 때, 기존의 '사용' 코드를 수정할 필요가 없어집니다. 연결: 부품을 만드는 방식(생성)만 외부 설정에서 바꾸면, 그 부품을 쓰는 객체(사용)는 자기가 바뀐 부품을 쓰는지조차 모른 채 그대로 동작합니다. 이것이 "수정에는 닫혀 있고 확장에는 열려 있는" 상태입니다.

③ 객체 간의 결합도(Coupling) 최소화 '생성'을 직접 하면 상대방의 구체적인 이름(클래스명)을 코드에 적어야 하므로 강하게 결합됩니다. 연결: '사용'만 하는 객체는 상대방의 이름 대신 **인터페이스(규격)**만 바라봅니다. 진짜 실체는 밖에서 넣어주기 때문이죠. 이로 인해 객체들은 서로의 존재를 깊이 몰라도 협력할 수 있는 느슨한 결합 상태가 됩니다.

이 분리가 이루어질 때 비로소 각 객체는 독립적인 부품이 될 수 있으며, 전체 시스템은 언제든 부품을 갈아 끼울 수 있는 진정한 객체지향 시스템으로 거듭나게 됩니다.

## **3-7 강한 결합과, 의존성 주입의 효율성 차이**

강한 결합의 주체는 개발자 자신, 의존성 주입의 주체는 IoC를 달성하기 위한 구체적인 방식인 '프레임워크'

DI는 생성과 사용을 분리하여, 개발자는 어떻게 효율적으로 사용할것인지에 대한 비즈니스로직에만 집중하고, 구체적인 생산은 프레임워크가 담당하여 속도와 효율성이 증가됨, 또한 객체의 생산이 수많은 개발자들로 부터 검증된 프레임워크가 담당하므로 질서적이고 구조적입니다.

## **3-8 강한 결합은 필요가 없는가?**

아니다.

1. 극단적인 성능 최적화가 필요할 때 의존성 주입(DI)이나 인터페이스를 통한 호출은 미세하게나마 성능 오버헤드(비용)를 발생시킵니다. 이유: 인터페이스를 거치면 실제 객체의 메서드를 찾아가는 과정(Dynamic Dispatch)이 추가됩니다.상황: 1마이크로초()의 차이가 중요한 임베디드 시스템, 고성능 게임 엔진의 렌더링 루프, 실시간 금융 거래 시스템에서는 복잡한 DI 구조보다 강한 결합을 통해 CPU가 가장 빠르게 실행할 수 있는 직접적인 코드를 작성하는 것이 유리합니다.
2. 절대 변할 리 없는 '도구' 성격의 클래스모든 것을 부품화 하면 오히려 코드가 너무 복잡해집니다(Over-engineering).이유: 수학 계산 함수(Math), 문자열 처리 도구, 날짜 라이브러리처럼 이미 표준화되어 있고 바뀔 가능성이 0%에 수용하는 클래스들까지 인터페이스를 만들고 주입받는 것은 시간 낭비입니다.상황: 유틸리티 클래스나 언어의 기본 내장 라이브러리를 사용할 때는 그냥 강하게 결합해서 쓰는 것이 생산성 면에서 훨씬 낫습니다.
3. 코드의 직관성과 가독성이 우선일 때느슨한 결합을 위해 인터페이스와 DI 컨테이너를 도입하면, 코드를 읽을 때 **"이 인터페이스의 실제 구현체가 어디에 있지?"**를 찾아다녀야 합니다.이유: 프로젝트 규모가 작은 경우, 파일 몇 개면 끝날 일을 DI를 위해 수십 개의 인터페이스와 설정 파일로 쪼개놓으면 오히려 흐름을 파악하기 힘들어집니다.상황: 프로토타입(시제품) 개발, 1인 개발, 혹은 수명이 아주 짧은 일회성 스크립트를 짤 때는 강한 결합으로 한눈에 들어오게 짜는 것이 더 효율적입니다.
4. 데이터 중심 객체 (Value Object / DTO)데이터를 전달하기만 하는 객체들은 굳이 DI를 할 이유가 없습니다. 이유: 데이터 객체는 로직을 수행하는 '부품'이 아니라 부품 사이를 오가는 '재료'입니다. 재료를 굳이 외부에서 주입받아 사용할 필요는 없죠. 상황: 사용자 정보(User), 주문 내역(Order) 같은 데이터 클래스들은 보통 필요한 곳에서 직접 생성(new)해서 사용하며, 이것은 지극히 정상적인 설계입니다.

## **3-9 DI의 문제점과 한계**

## 1. DI 남용이 만드는 문제 (Side Effects)

DI를 과하게 사용하면 시스템의 **복잡성(Complexity)**이 목적 없이 증가합니다.

- **가독성 저하 (Traceability Issue):** 코드를 읽을 때 특정 메서드가 어떻게 동작하는지 보려면 해당 인터페이스의 실제 구현체를 찾아 파일 사이를 계속 점프해야 합니다. "코드의 흐름"이 설정 파일이나 어노테이션 속에 숨어버려 직관성이 떨어집니다.
- **런타임 에러 가능성 증가:** 컴파일 시점에는 문제가 없지만, 프로그램이 실행될 때 주입할 객체를 찾지 못해 오류가 발생하는 경우가 생깁니다.
- **학습 곡선과 오버헤드:** 팀원 모두가 DI 컨테이너의 동작 방식과 복잡한 설정법을 숙지해야 하며, 컨테이너가 객체를 스캔하고 관리하는 데 따르는 약간의 성능 손실과 메모리 사용량이 발생합니다.

---

## 2. Over-engineering(오버엔지니어링) 사례

오버엔지니어링은 **"필요하지 않은 유연성을 위해 너무 많은 구조를 짜는 것"**을 의미합니다.

- **1:1 인터페이스 남발:** 클래스 `UserService`를 만들면서 관례적으로 `IUserService` 인터페이스를 무조건 만드는 경우입니다. 구현체가 하나뿐이고 앞으로도 바뀔 가능성이 0%라면, 이는 아무 의미 없는 코드 라인만 늘리는 행위입니다.
- **단순 유틸리티의 빈(Bean) 등록:** 문자열을 단순히 자르거나 날짜 형식을 바꾸는 독립적인 유틸리티 클래스까지 DI 컨테이너에 등록해서 사용하는 경우입니다. 이런 클래스는 `static` 메서드로 충분합니다.
- **비행기 로직으로 자전거 만들기:** 서울에서 판교까지 배송하는 코드(간단한 로직)를 짜는데, 나중에 화물선이나 비행기로 확장될 것을 대비해 거대한 추상화 계층을 만드는 것입니다. 정작 필요한 것은 당장의 배송 완료인데 말이죠.

| **구분** | **단순 new (직접 생성)** | **DI (외부 주입)** |
| --- | --- | --- |
| **객체의 성격** | **값 객체 (Value Object)**, 데이터 모델, 단순 유틸리티 | **서비스 (Service)**, 저장소 (Repository), 컨트롤러 |
| **상태 변화** | 내부 데이터가 자주 바뀌는 객체 (DTO 등) | 한 번 생성되면 상태가 거의 변하지 않는 객체 |
| **의존성** | 다른 객체에 의존하지 않거나 기초 타입만 가짐 | 외부 API, DB 연결 등 외부 시스템과 소통함 |
| **테스트** | 로직이 간단해서 가짜 객체(Mock)가 필요 없음 | 테스트 시 DB나 네트워크 연결을 가짜로 대체해야 함 |
| **변경 가능성** | 구현체가 바뀔 일이 절대 없음 | 실행 환경에 따라 구현체가 바뀔 수 있음 |

## 3-15 DI를 해야만 할때, 하지 말아야 할때

🎯 핵심 질문

> 이 객체는 DI 대상인가?
> 

이 질문은 결국

**“이 객체를 내가 직접 new 해도 되는가?”** 로 환원된다.

---

# 1️⃣ DI 안티패턴 관점의 답

### ❓ 언제 DI 대상인가?

- 객체가 **변할 가능성**이 있다
- 구현체가 **2개 이상**일 수 있다
- 테스트에서 **대체(mock/fake)** 해야 한다

### ❌ DI 대상이 아닌 경우

- 단순 계산 로직
- 유틸리티 함수
- DTO / VO

👉 **규칙**

> “바꿀 이유가 없으면 DI 대상이 아니다”
> 

---

# 2️⃣ IoC vs DI 관점의 답

### ❓ 언제 DI 대상인가?

- 객체 생성 시점이 **내 코드의 관심사가 아닐 때**
- 생성 순서 / 생명주기가 중요할 때

### ❌ DI 대상이 아닌 경우

- 호출할 때 바로 만들어도 의미가 변하지 않는 객체

👉 **규칙**

> “생성 책임을 넘기고 싶으면 DI 대상이다”
> 

---

# 3️⃣ DI 구현 방식 관점의 답

### Constructor Injection 기준

- 필수 의존성 → **DI 대상**
- 선택적 의존성 → DI 아님 or Setter

### ❌ DI 대상 아님

- 메서드 내부에서만 쓰이는 임시 객체

👉 **규칙**

> “생성자에 들어갈 가치가 있나?”
> 

---

# 4️⃣ DI 컨테이너 내부 동작 관점의 답

### ❓ 언제 DI 대상인가?

- 싱글톤 / 요청 스코프 등 **수명 관리가 필요할 때**
- 순환 참조 가능성이 있는 객체

### ❌ DI 대상 아님

- 상태 없음
- 라이프사이클 의미 없음

👉 **규칙**

> “컨테이너가 관리할 이유가 있나?”
> 

---

# 5️⃣ 테스트 관점의 답

### ❓ DI 대상인가?

- 단위 테스트에서 **가짜로 바꿔야 할 때**
- 외부 시스템(DB, API)에 연결될 때

### ❌ DI 대상 아님

- 테스트에서 실제 객체 써도 문제 없을 때

👉 **규칙**

> “테스트에서 바꾸고 싶은가?”
> 

---

# 6️⃣ AOP 관점의 답 (Spring 핵심)

### ❓ DI 대상인가?

- 트랜잭션
- 보안
- 로깅
- 캐싱

같은 **횡단 관심사** 적용 대상

### ❌ DI 대상 아님

- 순수 데이터
- 계산 전용 객체

👉 **규칙**

> “프록시가 필요하면 DI 대상이다”
> 

---

# 7️⃣ 언어 철학 관점의 답

### Java / Spring

- 클래스 중심
- 장기 운영
    
    👉 DI 대상 **많음**
    

### Python / FastAPI

- 함수 중심
- 단기 서비스
    
    👉 DI 대상 **적음**
    

👉 **규칙**

> “언어가 무거울수록 DI 대상이 많아진다”
> 

---

# 8️⃣ 아키텍처 관점의 답

### ❓ DI 대상인가?

- Boundary 계층
    - Controller
    - Service
    - Repository
    - Adapter

### ❌ DI 대상 아님

- Domain Entity
- Value Object

👉 **규칙**

> “경계에 있는 객체만 DI 대상이다”
> 

---

# 🧠 최종 결정 트리 (이거 외우면 됨)

```
1. 이 객체는 바뀔 수 있는가?
   └ NO → DI 대상 아님
   └ YES ↓

2. 테스트에서 대체해야 하는가?
   └ NO → 대부분 DI 아님
   └ YES ↓

3. 수명/생성 시점 관리가 필요한가?
   └ NO → new 해도 됨
   └ YES ↓

4. 횡단 관심사가 붙을 가능성이 있는가?
   └ YES → DI 대상

```

---

# 🔥 한 문장 정리 (이게 제일 중요)

> DI 대상은 “객체”가 아니라
“변화·테스트·경계”다
> 

## **3-10 전통적 DI의 구현: Spring Framework**

DI는 프레임워크를 토대로 구현되며 전통적 프로그래밍에서 DI를 달성하기 위한 프레임워크로 spring이 있다. 

프레임워크는 DI때문에 탄생한것은 아니고 

- 요청 처리, 라우팅, DB 연결, 트랜잭션, 로깅, 예외 처리

등의 반복작업을 효과적으로 다루기 위한 틀로 탄생했지만, 점차 기능이 확장되어 DI의 가치 IOC까지 담당하게 되었음

프레임워크는 우리가 비즈니스 로직에만 집중할 수 있도록 무대 뒤에서 다음 일들을 수행합니다.

### ① 빈 스캐닝 (Bean Scanning / Registration)

프레임워크는 애플리케이션이 시작될 때 설정 파일이나 특정 어노테이션(`@Component`, `@Service` 등)이 붙은 클래스들을 찾아냅니다. 그리고 이 클래스들을 **'관리 대상(Bean)'** 리스트에 등록합니다.

- **비유:** 공장에 들어온 부품들의 목록을 데이터베이스에 등록하는 과정입니다.

### ② 의존성 분석 (Dependency Resolution)

각 객체가 어떤 부품을 필요로 하는지 분석합니다.

- 예: "Car 객체를 만들려면 Engine 인터페이스를 구현한 부품이 필요하네?"라고 파악합니다.

### ③ 객체 생성 및 조립 (Instantiation & Injection)

가장 중요한 단계입니다. 필요한 부품들을 **순서에 맞게** 생성합니다. 만약 `Car`가 `Engine`을 필요로 한다면, `Engine`을 먼저 만들고 그 다음에 `Car`를 만들면서 생성자에 `Engine`을 쏙 넣어줍니다.

- **비유:** 조립 로봇이 엔진을 먼저 집어 차체에 끼워 넣는 과정입니다.

### ④ 생명주기 관리 (Lifecycle Management)

객체가 언제 생성되어야 하는지, 언제 파괴되어야 하는지(메모리 해제)를 관리합니다. 또한, 시스템 전체에서 단 하나의 객체만 쓸 것인지(Singleton), 매번 새로 만들 것인지도 결정합니다

spring은 실행시 Annotation기반 의존성을 강제로 주입, 의존성이 누락되면 앱 시작시 즉시 실패 한다. 구조가 명확하며 강제 된다. 연결이 실패하면 앱 자체가 실행되지 않으므로, 런타임 에러를 방지하는 **'설계 안정성'**을 보장합니다

## 3-11. FastAPI의 DI: 현대적이고 실용적인 접근

FastAPI의 핵심 가치 FastAPI의 가치는 크게 세 가지로 요약됩니다.

1. 속도와 성능 (Fast): NodeJS, Go와 견줄만한 Starlette과 Pydantic 기반의 고성능을 제공합니다.
2. 생산성과 직관성 (Easy & Fast to Code): 타입 힌트(Type Hints)를 적극 활용해 자동 완성과 에러 체크를 극대화합니다.
3. 안전성과 표준화 (Robust): OpenAPI(Swagger) 표준을 자동 생성하며, 데이터 검증을 철저히 하여 런타임 에러를 줄입니다.

FastAPI는 Java의 무거운 컨테이너 대신, Python의 타입 힌트와 `Depends()`라는 가벼운 함수를 활용합니다.

## **3-12 FastAPI DI의 작동 원리와 의의**

FastAPI에서 DI를 달성하는 방식: Depends() Java의 Spring 같은 프레임워크가 무거운 '컨테이너' 중심의 DI를 수행한다면, FastAPI는 Depends라는 매우 가볍고 직관적인 함수를 사용합니다.

① 함수 기반의 주입 FastAPI의 DI는 클래스뿐만 아니라 함수도 의존성으로 취급합니다. 특정 경로(Route)가 호출될 때 필요한 부품을 인자값에 Depends()를 적어줌으로써 주입받습니다.

Python

from fastapi import Depends, FastAPI

app = FastAPI()

**부품(의존성) 정의**

async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")

**Depends를 통해 필요한 부품을 주입받음**

async def read_items(params: dict = Depends(common_parameters)): return params 

② 계층적 주입 (Hierarchical Dependencies) 의존성 안에 또 다른 의존성을 가질 수 있습니다. 프레임워크가 알아서 의존성 그래프를 분석해 하위 부품부터 차례대로 생성해서 최종적으로 주입해 줍니다.

③ 타입 힌트와의 결합 어떤 타입의 객체가 주입될지 Python의 타입 힌트로 명시합니다. 이를 통해 개발자는 코드 작성 시점에 IDE의 자동 완성 도움을 완벽하게 받을 수 있습니다.

1. FastAPI DI만의 차별점 "코드 중복 제거와 가독성의 승리" 전통적인 프레임워크에서는 인증(Auth), 데이터베이스 연결(DB Connection) 등을 처리하기 위해 복잡한 미들웨어나 데코레이터를 덕지덕지 붙여야 했습니다. 하지만 FastAPI는 이 모든 것을 Depends 하나로 해결합니다.

재사용성: 한 번 만든 get_db 함수를 수백 개의 API 경로에서 재사용할 수 있습니다.

테스트 용이성: 테스트 시에 app.dependency_overrides 기능을 써서 진짜 DB 연결 함수를 가짜(Mock) 함수로 아주 쉽게 갈아 끼울 수 있습니다.

1. 요약: FastAPI에게 DI란? FastAPI에서 DI는 단순히 객체를 조립하는 도구를 넘어, **"HTTP 요청이 들어왔을 때 필요한 모든 데이터와 자원(DB, 보안, 설정)을 깔끔하게 정리해서 함수 입에 넣어주는 배달 시스템"**입니다.

이 덕분에 개발자는 "어떻게 데이터를 가져올지" 고민하지 않고, 주입된 데이터를 **"어떻게 요리할지(비즈니스 로직)"**에만 집중할 수 있게 됩니다. 이것이 바로 우리가 앞에서 다룬 생성과 사용의 분리가 FastAPI 스타일로 구현된 모습입니다.

### "코드 중복 제거와 가독성의 승리"

전통적인 프레임워크에서는 인증(Auth), 데이터베이스 연결(DB Connection) 등을 처리하기 위해 복잡한 미들웨어나 데코레이터를 덕지덕지 붙여야 했습니다. 하지만 FastAPI는 이 모든 것을 **`Depends`** 하나로 해결합니다.

- **재사용성:** 한 번 만든 `get_db` 함수를 수백 개의 API 경로에서 재사용할 수 있습니다.
- **테스트 용이성:** 테스트 시에 `app.dependency_overrides` 기능을 써서 진짜 DB 연결 함수를 가짜(Mock) 함수로 아주 쉽게 갈아 끼울 수 있습니다.

## **3-12 DI를 달성하기 위한 프레임워크 구분**

**Spring DI는 “설계 안정성”을 산다**

**FastAPI DI는 “속도와 단순함”을 산다**

| 항목 | Spring Boot | FastAPI |
| --- | --- | --- |
| DI 철학 | 컨테이너 중심 | 함수 합성 |
| 생성 시점 | 앱 시작 | 요청 시 |
| 검증 시점 | 시작 시 실패 | 런타임 실패 |
| 생명주기 | 컨테이너 | 요청 기반 |
| AOP | 매우 강력 | 거의 없음 |
| 구조 강제 | 강함 | 약함 |
| 테스트 | 쉽고 체계적 | 간단하지만 수동 |
| 규모 확장 | 매우 유리 | 일정 규모 이후 힘듦 |

## **3-13 Fastapi는 대규모 확장이 불가한가?**

아니다.

하지만 fastapi로 DI를 쓸때 망하는 패턴들이 있다. 이럴때는 spiring으로 전환해야 한다.

Depends의 의존성이 높다.

- Depends 체인이 길어짐
- 이 API가 뭘 쓰는지 파일 열어봐야 앎
- 리팩토링이 두려움

의존성 관계를 머릿속으로 못 그릴 수준으로 프로그램이 발달하였으며 이때는 전환이 필요하다.

객체 요청의 횟수가 많다. 

- Service 클래스가 1,000줄 이상
- 도메인 로직 중복
- “이건 저 서비스 책임 아닌가?” 논쟁 잦음

서비스 하나에 “비즈니스 규칙”이 너무 많아진 상태로 전환이 필요하다.

테스트가 어렵다

- 테스트 코드가 본 코드보다 복잡
- mock 주입 때문에 테스트 회피
- CI에서만 깨짐

depends 는 호출 시점에 실행되므로, 전역 상태나 외부 라이브러리가 섞여 있으면 테스트 격리가 매우 힘듭니다. 이럴 때는 **컨테이너 기반 테스트 필요**

# 4번(김영우)

# 5번(백시관)










