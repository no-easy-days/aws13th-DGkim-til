# 강의 git, github Cli 
- 한줄 키워드 학습 :  https://www.notion.so/ej31/12-24-2d3954dac7558081a2f5c884c490fb52?v=2cf954dac75581aa9afd000cc959191b&source=copy_link

# git 의 내역
이전에 프로젝트의 결과물의 관리는 워드,엑셀들 내부 문서로 관리하는 경향이 있었으나, '코드'는 수정이 잦고 그 단위가 미세할수도 있기에 이를 효과적으로 추적 관리하는
계념인 VCS의 계념이 탄생했다. 이중 git이 없었을때의 버전관리는 SVN 이란 중앙집중 방식의 버전관리 프로그램을 이용 하였다. 하지만 SVN시스템의 관리는 
다중 인원 협업시 이력 추적에 어려움 그리고 중복과 덮어쓰기 의 문제가 발생하였고 이에 따라 git이란 분산 관리 시스템이 떠오른다. git은 빠르고 간단하게
여러 작업의 변동 사항을 추적하는 것이 가능하게 해주었다.

- 코드의 이력을 추적 관리하는 이유는 무엇인가?(코드를 과거로 되돌릴 필요가 있을까?) = 버전관리의 이유
: 실수를 수정하는것, 각 이력(버전)의 상태를 확인 분석할때, 법적문제등으로 인하여 이전의 코드와 비교 하여 특정시점의 책임소재를 명확히 하기위함(SI회사의 문제),
expriment, rc, nightly 등 각 버전에 대한 여러 실험을 해보고 싶을때

- VSC의 특징 : 누가 언제 무엇을 변경했가를 추적 관리하는 프로그램

# git의 강점

1. 여려명이 동시에 작업 하여도 그 변동 이력을 '추적'이 가능하며, 특정 시점으로 및 특정 시점의 특정 부분으로의 '복원'이 가능하다(Cherry Picking). 
   또한 이력 추적이 가능하므로 다중 '협업'이 가능하다.  또한 각자 로컬에 분산 관리 하여 저장하기 때문에 원격저장소(Remote)의 코드가 소실되어도 '복구(백업)'가 가능하다.

- Remote : 로컬이 아닌 인터넷 환경에서 작동하는 저장소
- Git : 작업 파일들을 '분산' 관리하여 이력을 추적해주는 프로그램
- '분산' 이란 키워드는 '동시성 제어'와 '충돌'이란 키워드가 핵심
- 동시성 제어는 여러 동시 요청을 효율적으로 제어하는 방식
- 충돌은 동일 파일의 동일 부분의 코드가 충돌할때 발생

2. 원격저장소의 코드를 여러명이 '동시'에 클론이 가능하다. 네트워크가 따로 없이 클론된 코드를 로컬에서 작업이 가능하다. 원격저장소 코드시 로컬의 코드가 살아있다면
   복구가 가능하다(코드를 분산관리 하기때문에 가능)
   
# git의 사용

## git config
먼저 git config로 사용자의 정보를 입력하여 git을 활성화 시켜주는 것이 중요하다.
git은 다중 사용자들의 변경내역을 추적하는 만큼 해당 파일의 수정자가 누구인지 표기하는 것이 중요하기에 해당작업을 진행한다.
user.name / user.email은 커밋시 커밋 메타데이터에만 영향을 미친다. 
user.name / user.email이 github의 아이디와 이메일과 다르더라고 github에 push는 가능하나 커밋 이력이 달라 추적이 어럽다. 
그러므로 config설정시 user.name / user.email은 실제 github 아이디, 이메일과 동일시 하는것을 추천한다.

- git을 윈도우 터미널로 이용시 git bash를 이용하는것을 추천, 리눅스 기반 bash로 여러 명령어 사용가능
- 맥은 아이텀, 코스티
- git과 관련된 원격과 인증의 작업의 문제시 git config --list의 내용을 확인해 보기
- git config --globbal / --local 명령어 대부분은 global을 쓰나 일부 시스템에서 local을 쓰기도 한다.

## git init
작업 디렉토리(나의 로컬폴더)안에 git 저장소를 생성한다. 실제 디렉토리 안에 .git폴더가 추가되며 작업디렉토리의 변경사항들이 저장된다.

## git add
git은 코드변경을 자동 저장하지 않으며 의미있는 단위로 묶어 커밋이라는 과정을 거쳐야 이력이 저장된다.
git은 작업 디렉토리 - 스테이징 - 커밋이라는 과정을 거친다. 
- 작업 디렉토리는 실제 내가 코드를 수정하는 공간으로 실제 폴더의 이름을 칭한다.
- 스테이징을 내가 실제 코드를 수정한 파일을 올리는 공간으로 커밋전에 불필요한 파일을 걸러주어 커밋의 목적을 명확하게 하는 단계이다.
- 커밋은 스테이징 단계에서 의미있는 단위로 묶인 파일들의 변경 내역을 git 저장소에 저장한다.
git add는 내 작업디렉토리의 결과물을 스테이징 단계에 올리는 행위

 ### git add 시나리오 (bash상 작업 디렉토리 안의 파일을 생성하여 스테이징에 올리는 과정)
1. vim "README.md" -> README.md란 파일을 생성한다.
2. vim 을 사용시 README.md 파일의 내부를 작성할수 있으며 'I'를 사용하여 해당 내용을 수정한다
3. esc를 눌러 빠져나온후 'w' (저장), 'q'(닫기), 혹은 'wq'(저장후 닫기) 를 눌러 빠져나온다.
4. 작업 디렉토리에 README.md 파일이 생성되었으며 이를 스테이징에 올린다. 
  bash 상 git add "파일의 이름을" (git add "README.md"쓰지만, 작업 디렉토리의 모든 파일을 올릴시는 git add . 를 쓴다.

## git commit
staging에 있는 파일들의 변경 내역을 내 로컬/리모트 상에 저장 하는 행위로, 스테이징에 올라와 있는 파일을 로컬 저장소에 영구 기록 한다.
commit은 명령 실행시 작업 메세지가 필요하며 해당 파일의 어떤 부분이 수정되었는지 명확히 표기해 주는게 중요하다.

 ### git commit 시나리오 (bash상 commit 하는과정)
1. git add . 로 스테이징에 파일이 올라와있는 상황
2. git commit 명령어로 커밋 메세지 에디터로 들어가서 커밋 메세지를 칠수 있고
3. git commit -m "~~~" 으로 바로 "~~~"의 커밋 메세지를 쓸수 있다.

## git log 
git log는 나의 커밋이력을 표시해주는 명령어로 커밋이 완료될시 일정수의 해쉬값이 저장되며 해당 해쉬값을 참조한다.

## git status
git status는 내 작업 디렉토리 안의 파일들의 상황을 알려주는 명령어로 어떤 파일이 add가 되어 있는지 새로 생생된 파일이 무엇인지 알려준다.

## branch
main에서 갈라지는 독립적인 작업 공간, 파일을 실제로 복사하는 것이 아니라 이력사항을(특정 커밋) 포인팅 하고 있을뿐이다. 파일의 수정 사항이 있을시 어느 부분이 갈라졌는지만 추적한다. 

- 원본 사항에서 바꾼 이력만을 추적하며, 지워도 원본에 영향이 가지 않는다.
- 브랜치는 커밋사항을 포인팅 하는것이며 만일 main에서 바로 브랜치 생성시 생성 브랜치는 main브랜치를 포인팅 하는 것이 아니다.
  * ex:  commit b0d4ec9b414c2e4973d017bc2ec9333a9d2baf40 (HEAD -> feature/login, master)
  * 이 경우는 브랜치가 메인과 동일한 커밋사항을 포인팅 하는것이며, 현재 head가 feture브랜치를 바라 본다,
  * 브랜치에서 새로운 커밋이 일어 날경우 그 커밋으로 포인팅 한다.
- 브랜치의 변경사항을 main으로 merge할수 있으며 (로컬), 리모트일시 pr을 통해 리모트 origin에 merge가 가능
- 브랜치 생성시 이름을 feture/login, hotfix/login 으로 생성하여 "/" 로 구분을 지어주면 파싱기능에 용이하다.
###  git branch 
브랜치 생성 명령어, git branch -d "이름" 병합된 브랜치만 삭제 -D 병합상관없이 강제 삭제
### git switch
브랜치 이동할때 쓰는 명령어, git switch -c "브랜치이름" 일시 브랜치를 생성후 바로 이동
git checkout과의 차이 -  switch는 브랜치 전환만 가능, checkout는 브랜치, 헤드등 모두 이동 가능

## head(실습 사항은 1차 과제 확인!)
현재 내가 바라보는곳, git에서의 head는 단 한개만 존재

- head의 역할 : 현재의 브랜치를 추적하는것, head가 브랜치를 경유하지 않고 커밋을 바라보고 있으면 고아 객체가 발생

- head를 확인하는법 (1차과제에 자세내용 참조)
* git blanch로 *모양의 브랜치가 현재의 head모양
* git log로 확인
* cat .git/HEAD
- head의 상대참조 : HEAD~숫자
- 고아 객체 (도달불능 헤드 Detached HEAD) : 헤드가 브랜치를 바라보지 않고 특정 커밋을 바라보는것, 해당 상태에서 새로운 커밋을 추가하고, 어떠한 브랜치로 이동하면 head가 해당 브랜치로 이동해버리며 그 브랜치는 이전에 커밋을 가르키지 않으므로, 추가되었던 커밋은 어떠한 참조 정보가 없으며 도달 불능의 상태가 된다. 이를 방지 하기 위해서는 고아 객체 상태의 헤드에서 커밋이 생성시 브랜치를 반드시 생성에서 참조 할수 있는 정보를 만드는 것이 중요하다.
  
## branch strategy

### git flow strategy


### github flow strategy



# github Cli








