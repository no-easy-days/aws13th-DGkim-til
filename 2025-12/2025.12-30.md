# 파이썬 

## 파이썬 설정 
- uv (차세대 채키지 툴)
- 최신 버전 3.14 쓰레드 관련 변경사항 
- 프로그램 생성시 .venu라는 가상환경 설정 생성(버전 충돌 문제 해소)
- 콘솔상 exit code 0 코드종료는 정상종료

## 파이썬 기초
- 콘솔창에 결과를 띄우기 위해서는 출력 함수를 사용
- 아무 함수도 쓰지않고 1, 문자를 입력해도 오류가 나지않고 작동은 함
- 문자형은 ""를 쓰고, 숫자형은 아라빅 숫자를 바로 사용
- 숫자 + 문자는 에러 (자료형이 다름), 문자+문자 숫자+숫자 가능
- 파이참 작동시 tranlation 플러그인 이용하면 에러 메세지 번역 해줘서 편리
- 설정 키맵에서 단축키 설정도 가능
- ctr+window 단축키로 프로젝트 상 내장함수의 실제 함수 문법을 읽어볼수 있다. 

## 변수
- 계산값(결과값,실행값)을 저장 받는 특정한 이름
- (   )    =  1+1 
- 변수값,저장값 =  자료값,결과값,실행값
- 변수의 필요이유 : 변수가 있어야(어딘가에 결과값을 저장해놔야) 코드의 반복성을 막으며
각종 비즈니스 로직(원하는 기능을 동작하게 하는 코드)에 활용이 가능하다.
- 변수값이 없다면 모든 비드니스 로직에 결과값을 직접 입력하여 사용해야 하기에 불편하다.


### 변수의 활용

- 변수에게 결과값 저장  var = 1+1 (1+1의 결과값을 변수에 저장)
- 변수의 출력, print(변수의 이름)
- 변수의 수정(재할당) var=1 , var =2 (변수 var의 값을 1에서 2로 바꾸기)

### 변수 심화
1. 변수의 메모리 참조
var = 1+1
var = 2+1 
변수가 새로운 값을 재할당 받으면 메모리상 새로운 값을 참조하게 된다. 이전값은 가비지 컬랙터(GC)로 사라지고
릴리즈 된다. GC가 너무 많이 쌓이면 leak 위험이 있다.
2. 파이썬 특징
파이썬은 인터프리트 언어로 int등 다른 데이터 타입을 선언하지 않고 사용이 가능하다.

### 변수의 특징
1. 변수는 단일  값만이 아니라 모든것을 담을수 있다.
- 모든것의 의미
  - 자료형 : int,str, bolean 등등
  - 오브젝트형 : 클래스, 함수,콜백을 위한 것들,리스트, 딕셔너리 등등

2. 변수의 이름 규칙(Naming Convention)
- 기업은 각자의 이름 규칙을 문서화 하여 린팅(버그,코드스타일,규약을 검증하는 도구)한다.
- 변수의 이름 규칙을 지켜야 상업적 개발이 가능하다.
- 파이썬 언어 자체에서 암묵적 규약
  * 변수의 시작은 반드시 문자 또한 언더바(_) 로 한다.
  * 변수 시작은 하이픈(-), 숫자 생성은 안된다
  * 0~9, a~z, A~Z, 한글도 가능
    * 한글 변수는 실무상 테스트코드에서 사용, 테스트 코드에서 가독성과 효율성을 위해서 간혹 사용
  * 변수 중간에 공백은 불가
  * 예약어는 변수명으로 사용 불가
    예약어 : 특정 기능을 수행하도록 파이썬 자체에서 지정해 놓은 단어(if, for, class)
- naming convention 
    - 스네이크 케이스 is_logged ('_' 언더바 이용, 모두 소문자)
    - 파스칼 케이스 IsLogged (첫글자포함 각 단어의 첫번째 char이 대문자)
    - 카멜 케이스 isLogged (첫글자는 소문자, 각 단어의 첫번째 char은 대문자)
    - 스크림 케이스 IS_LOGGED (모든글자 대문자 단어사이는 _ 로 구분)
    - 변수에서는 스네이크 케이스를 위주로 하고 클래스에서는 파스칼 케이스로 주로쓴다. 
- 변수 이름 생성에 도움 되는 사이트 (https://www.curioustore.com/)

### 변수의 연산
- 숫자+숫자 = 가능
- 문자+문자 = 가능
- 문자+숫지 = 불가능
- 복합 연산 : count +=1 (count 변수값을 더하고 다시 count에 저장, 처음에 count값을 지정해줘야한다.)
- 다중 할당 : 자바스크립트 구조화와 비슷, 체이닝 할때, 여러값을 순서대로 넣을때 사용(각기 변수에 같은값, 또는 변수마다 다른값 할당 가능)
- 값 교환(스왑) : 변환값을 담는 임시변수 없이, a=b, b=a로 바로 값교환이 가능

### 파이썬의 개발 흐름
  * 변수-함수-클래스-쓰래드 (파이썬 언어 차원의 기본 단위)
  * 리팩토리-디자인패턴 (코드 품질과 방법 설계론)
  * 아키텍쳐-인프라 (시스템 전체 구조와 실제 환경)

## 자료형
- 자료형 : 데이터의 종류
- 자료형은 print() 함수에서 출력해서 값을 볼수 있다
- type()을 이용하여 결과값의 자료형을 볼수 있다. (자바는 isinstance, instanceof)

### 함수에 대한 기초 설명

  ```
    def add(a,b) 
      return a+b  란 함수가 있다면 
  ```
- def는 define의 의미, 예약어, 함수로 사용할것이라고 선언
- add는 함수의 이름, 사용하려는 함수의 이름을 지정
- (a,b)는 함수가 사용시 받을 데이터
- return 함수의 결과값을 반환하고 함수를 종료하는 예약어
- a+b 함수의 결과값

### 함수의 종류
1. 사용자 함수 : 사용자가 선언 하여 사용하는 함수
2. 빌트일 함수 사용자가 따로 선언하지 않아도 파이썬에서 자체적이로 선언하여 미리 빌트인 시켜놓은 함수,
bulits.py 스크립스에 빌트인 함수들이 미리 선언하여 포함되어 있다. print() 같은 함수들

### 자료형이 필요한 이유
컴퓨터는 여러 성질을 가진 데이터를 바로 인지 할수 없다. 컴퓨터 차원에서 알아볼수 있게 자료형을 선언하여 데이터를 올바르게 쓰기 위함
- 문자 + 숫자 가 불가능한 이유 : 자료형이 다르기 때문에 컴퓨터가 연산을 할수 없다
- 각기 다른 자료형을 맞추기 위해 빌트인 함수를 사용하여 캐스팅하여 사용한다.
- 캐스팅 : 자료형의 형식을 변환하는것

```
var = 5 +"100"  : 해당 코드는 자료형이 달라 연산이 불가
var = 5 + int("100") : "100"이란 문자열을 정수형으로 바꾸는 
int() 빌트인함수 사용

var = 5 + int("백") : 에러, int()함수에 문자열은 정수를 담고 있어야
만캐스팅이 가능하다. 
var = 5 + int("3.14") : 에러, 문자열이 숫자를 포함해도 정수가 아니기 
때문에 캐스팅이 불가하다. 이때는 float()이란 다른 함수로 캐스팅한다. 

```

### 숫자형
1. 정수 - 파이썬은 정수의 숫자 제한이 없다.
2. 실수 - 부동소수점 
- 컴퓨터는 실수를 2진수로 계산하기 때문에 실수에 변환에 대한 오차가 발생한다.
  - 일부 10진법에서는 유한 소수가 2진법에서 무한 반복 소수로 변환하기 때문에, 
  메모리 한계상 무한 소수를 담을수 없고 근사치만 표현된다.
- 실수를 10진법으로 정확히 계산하고자 한다면 decimal 모듈을 사용한다.

### 문자열
- str, 글자들의 집합 - c언어에서 문자열을 char단위로 한단어씩 처리하던것을 string 클래스로 묶어 운영하던 방식에서 유래
- 생성 방식 
  - 일반문자열 생성 : "문자열"
  - 삼중따옴표 방식 : ''' ~~ ''' 여러줄을 한번에 쓸수 있기에 이메일 자동 발신 기능개발등
- 문자열은 인덱스가 존재한다.
  - 인덱스는 순서의 번호, 메모리의 시작위치의 거리를 의미 0부터 시작한다.
  - 인덱스가 있으면 '리스트'의 형식을 띄고 있다. 
  (인덱싱이 가능하다는 것은 시퀀스 자료형을 의미하지만, list는 가변 시퀀스 자료형이며
  str은 불변 시퀀스 자료형이다. str을 list처럼 이해할수는 있지만 역활과, 실제 타입의 쓰임이 다르다)

```
1.str은 읽기 전용 시퀀스 자료형으로 인덱싱이 가능하지만 수정이 불가하다.
s = "Python"

# 리스트처럼 인덱싱 가능
print(s[0])    # P

# 리스트처럼 슬라이싱 가능
print(s[:2])   # Py

# 리스트처럼 개수 세기 가능
print(s.count('o')) # 1

2.list처럼 수정,삭제를 하고 싶다면 str-> list로의 형변환이 필요하다.

# 1. 원본 문자열
my_str = "apple"

# 2. 리스트로 변환 (str -> list)
# 이렇게 하면 ['a', 'p', 'p', 'l', 'e'] 형태가 됩니다.
str_list = list(my_str)

# 3. 리스트이므로 특정 위치의 글자 수정 가능
str_list[0] = 'A'
str_list[4] = 'y'

# 4. 리스트를 다시 문자열로 합치기 (join 메서드 사용)
# ''(빈 문자열)을 기준으로 리스트의 요소들을 붙입니다.
result_str = "".join(str_list)

print(result_str)  # 출력: Apply

```
- 이스케이프 문자 : 특수한 역할을 하는 문자 (\로 사용)
  - \t (tap으로 띄어쓰기), 
  - \n(한줄 바꾸기,개행)
  - 정규식을 사용하기 위해서도 이스케이프 문자가 필요하며, 정규식은 re모듈도 필요하다 
  
- fstring
  * 포맷 스트링 : 문자열 안쪽에서 변수를 바로사용 가능
  * {변수 : x} - ':' 콜론으로 변수의 포맷을 직접 설정할수 있다.
```
f-string에서 콜론(:) - **형식 지정자(Format Specifier)**의 시작점입니다.
주요 기능:
{val:.2f} : 소수점 자릿수 제한
{val:,} : 천 단위 콤마 삽입
{val:^10} : 가운데 정렬 및 폭 설정
```
### 논리형
- Ture / False라는 2가지의 예약어로 만들어져 있는 자료형
- 논리상 T는 '존재한다', 숫자 : 1 / F는 '없다','숫자 : 0
- ! 는 not, 아니다, 반전의 의미
- 논리연산자
```
      a   b  / r(결과)
and   T   T  /  T
      T   F  /  F   and는 둘중 모두가 T여만 한다
      
or    T   T  /  T
      T   F  /  T   or는 둘중 하나만 T이면 된다.
```
- 논리연산자의 구체적 시나리오
```
AND조건(둘다 모두 만족)
유저가 어드민이면서,아이디에서 어드민 값을 포함할때
20살 이상이면서, 남자일때
가입기간이 한달을 넘으면서, 핸드폰 인증을 완료한 유저일시

OR조건(둘중에 하나만 만족)
핸드폰 인증 혹은 이메일 인증 둘중 하나를 완료한 유저
```
### None 타입 
- 값이 없음을 나타냄, 길이가 존재하지 않음
- 함수에서 return이 없으면 None 값을 반환한다.
- None 체킹 할때 
  * is라는 예약어를 사용한다, is는 if제어문에서 사용
  * if value is None -> None은 싱글톤객체
  (유일객체, 부모 클래스는 Nonetype)로 객체의 유일성을 비교할시
  단한개만 존재하기 때문에 비교가 용이하고 정확하다.
  * if value == None -> == 는 값만을 비교하므로 None값이 오버라이딩
  될경우 에러가 발생한다.

### 타입 형변환 
데이터의 자료형을 다른 자료형으로 바꾸는것
1. 명시적 형변환 : int(),str(),float()을 사용

2. input() 함수의 특징 : input은 사용자의 입력값을 "문자열"로 받으므로
이 데이터를 쓰려고 할시 용도에 맞게 형변환을 해줘야 한다.
- 콘솔상 간편하게 input()함수로 받을수도 있고, 웹이나 API상으로 유저의 브라우저, 유저의 
http리퀘스트를 통해 값을 받을수 있다.

## 여러개의 값을 같는 자료형(컬렉션 자료형)
여러개의 데이터 값을 하나의 변수로 관리하는것
리스트, 딕셔너리,튜플, 세트 등, 실무상 튜플은 db 데이터 연결에 자주 사용

### 리스트 
1. [], 대괄호로 사용한다.
2. 자료를 순서대로 저장, 순서가 존재=인덱스가 존재
3. 인덱스는 메모리부터의 거리를 의미한다.
- index[0] -> 리스트 자료형의 가장 첫번째 자릿수, 메모리 위치를 시작하고 있기 때문에 0으로 표기한다.
- index[-1] -> 리스트 자료형의 가장 마지막 자리, 맨뒤의 첫번째 숫자를 의미 (-2 : 맨뒤에서 시작해서 2번째 숫자)
4. CURD방식(Create, Read, Update,Delete) 
- list = []이라고 할시
- C : 리스트에 값을 추가하고자 할때
  * list.append() -> 리스트 뒤에 추가값 이어붙이기
  * list.insert(1,값) -> 원하는 위치에 값을 끼워넣기
- R : 리스트의 값을 가져올때
  * list[index 값] -> index 값은 0에서 부터 시작
- U : 리스트의 값을 수정하고자 할때
  * list[index 값] = 수정할 값 -> 특정 인덱스의 값을 직접 수정이 가능
- D : 리스트의 값을 삭제할때
  * list.remove(값) -> 리스트 첫번째로 찾은 값만 제거, 똑같은값 중복시 가장 왼쪽 첫번째만 삭제된다.
  * list.pop() -> 리스트 가장 마지막 부분을 제거, pop(index 값)으로 쓰면 특정 index값을 찾아서 제거

- pop()에 대한 시나리오
  * queue(큐) 자료 구조형을 구현할시 pop사용하여 데이터를 추가하고 필요없는 값을 내보내는 식으로
  리스트에서 순차적인 실행 구조를 보장하는 방식의 큐 방식을 구형할수 있다.
 - append는 db나 여러 완성된 데이터를 가져오는 경향이 있기에 잘 쓰이지 않는다.
 - 순차실행할때 pop, reverst등 사용
 - 코드상 list를 '삭제' 하는 행위는 지양, 다른 리스트로 빼서 사용

### 딕셔너리
1. {key : value}, 중괄호를 사용하여 저장하고, 각 테이터는 콜론을 기준으로 키와 밸류값을 같는다.
2. key는 value를 찾아가는 방법(불변하는 값이며, 해시 가능한 값이면 가능 - 단일 자료형, 튜플)
3. value는 어떠한 자료형이든 저장이 가능하다.
4. CURD방식(Create, Read, Update,Delete) 
- dict = {}, 빈 dict 선언
- C 
  * dict[키값] = value값, dict는 키:값 쌍으로 존재하며, key없이 val이 단독으로 존재할수 없으며
  key가 있고 val이 없는 경우는 없다(key의 val을 None이나 "" 같은 공란으로 임의로 만들어 값없음 상태를 만들수는 있음)
  * dict.update({키:값,키:값}) -> 여러개의 값을 한꺼번에 추가하기, 추가된 값은 기존 dict값 뒤에 이어져서 추가된다. 
- R
  * dict[키값] -> 키에 대한 val나옴
  * dict.get(키값) -> 키에 대한 val 나옴, 만약 없는 키값이면 None을 반환한다. 이는 get()함수가
  return 값이 없을시 none을 반환하기 때문
  ```
  dict.get(키값)의 결과가 none을 쓰는 시나리오
  :   db등의 정보를 가져올때 get()함수로 검증

  유저데이터값이 존재할때 get()함수는 키에 대응 하는 결과값이 존재할것이라는 비즈니스 로직을 함유
  만일 dict[키값]으로 값을 읽으려할때 key값이 존재 하지 않아 프로그램 에러가 나는 경우를 방지하기 위해
  none값을 반환하는 get()함수를 이용해서 none값을 처리하여 적절한 응답을 반환하는 방식
  ```
- U
  * dict[키값]= val값 -> key 값에 새로운 val을 덮어쓴다.
- D
  * del 예약어 사용 
  * del dict[키값] -> 해당 키값이 가르키는 val 삭제(이후 key도 삭제됨)
  * del dict.get(키값) -> 불가, get()는 함수의 특징상 결과값만을 반환할뿐 참조 정보가 없다.
  * dict.pop(키값) -> 해당 키값의 val을 들어내기, 삭제의 기능을 한다.
  * dict.clear -> 모든 값 삭제
컨스트럭팅, 키맵핑 dto enttity?

5. dict의 Iterable(반복가능하게)방식

```
for k,v in dict.items():
    print(k,v)
    
    k는 key 약어, v는 value 약어
    item()은 모든 key, val을 튜플로 묶어서 반환하는 함수
```
### 문자열
문자열은 글자들이 순서대로 연결된 집합체

### 튜플
순서가 존재하나 한번 생성후 수정불가

### 세트
중복을 허용하지 않는 무작위 