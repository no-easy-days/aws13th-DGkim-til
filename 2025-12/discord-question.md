# 1 dict자료형에서 값을 value->key로 가져오는법?
김동균
작성자
 — 오후 3:21
dict 자료형에서 key값으로 value를 찾을수 있으나, 반대로 value값을 통해서 key를 찾을수 있는 방법이 있는지요?
해당 방식을 지원하는 빌트인 함수가 있는지요?
해당 방식이 실무상 쓰이는 방식인지, 아니라면 왜 쓰지 않는지 알고 싶습니다.
jeff — 오후 4:49
하나씩 살펴보겠습니다!

결론부터 말씀드리면 값을 통해 키를 찾는 별도의 내장 함수는 없습니다.
값으로 키를 찾으려면 결국 모든 키를 순회해야 합니다. 그래서 성능에 문제가 생기게 되는데요 시간복잡도가 O(1) -> O(N) 으로 늘어나는 문제가 생깁니다.
(지금 프로젝트에서는 크게 상관없지만 실무를 언급하셨으니...... 엄격하게 본다면 이런것도 신경쓴다는 뜻입니다.)
또하나 크리티컬한 문제는 dictionary의 키는 고유함을 보장하지만 value는 그렇지 않습니다. 그래서 둘을 뒤집어서 따로 저장하는 기능을 만든다고 한들 결국 중복 되는 value는 사라질 수 밖에 없습니다.
변경 전
  { 
    "apple": 1000, "banana": 2000, "orange": 1000, "kiwi": 3000
  }


  
변경 후
  {
    1000: 'orange', 2000: 'banana', 3000: 'kiwi'
  }

  
변경후를 살펴보면 천원짜리가 사라져버리는 문제가 생기게 됩니다. 그래서 실무에서는 다이렉트로 쓰기 어렵습니다.

그럼에도 바꿔서 검색을 해야 하는 경우가 간혹 생깁니다. 그럴 때 쓰는게 바로로바로바로! 역방향 색인이라고 해서 defaultdict 라는 collection 쪽 패키지 사용하는 방법이 있습니다.

예시 하나 가져왔는데 아래 내용 참고해보세요  (* 조금 어려울 수 있는데 코드는 아래에서 하나씩 차근히 설명해볼께유)

```
from collections import defaultdict

# 1. 중복된 값(1000)이 있는 원본 데이터
original_dict = {
    "apple": 1000,
    "banana": 2000,
    "orange": 1000,
    "kiwi": 3000
}

# 2. 역방향 딕셔너리 생성 (값 -> 키 리스트)
# 값을 키로 하고, 내용을 리스트([])로 초기화
reverse_dict = defaultdict(list)

for key, value in original_dict.items():
    reverse_dict[value].append(key)

# 3. 결과 확인
print(dict(reverse_dict))

# 역색인 하고난 후 reverse_dict 결과는 아래처럼 생겨 먹었습니다.
# {
#     1000: ['apple', 'orange'], 
#     2000: ['banana'], 
#     3000: ['kiwi']
# }


```

핵심은 defaultdict(list) 입니다.
이렇게 선언하면 defaultdict 에 키가 생성 될 때 자동으로 value 에 list 가 들어가는 겁니다.
그래서
for key, value in original_dict.items():
    reverse_dict[value].append(key)

이런 코드가 가능해지는 것이지요. 그리고 키 값에 O(1) 의 시간복잡도로 접근할 수 있으니 성능상에도 문제가 없답니다!

저는 크롤러 만들 때 값 비교 할 일이 많아서 자주 쓰던 방식입니다.

🔥

# 2 dict 자료형의 del을 왜 비선호 하는가?
강의 중, dict 자료 구조상 delete를 바로 쓰기 보다는, 컨스트럭팅, 키매핑, dto-entitiy, entitiy-dto 등의 방식을 선호한다. 이 말의 의미가 무엇인지 알고 싶습니다. 

jeff — 오후 5:04
음.. 이거 좀 긴 얘기입니다. 하나씩 차근히 써볼께요
요약하자면..
원본 데이터를 훼손하지 말고 (불변! immutability) 정확하게 설계도를 통해 (class) 데이터를 변환해야 한다는 뜻입니다.

이거 수업할 때 얘기 나온게 del 예약어 쓸 때 였는데요 왜 del 을 쓰는게 별로인지 몇가지 정리해서 풀어볼께요 
두세개 정도 관점이 나올것 같습니다
jeff — 오후 5:12
지우기보다는 새로 만들기(constructing) 하는게 낫다.
파이썬에서 del dict['key'] 혹은 pop() 을 사용하면 기존 딕셔너리 자체를 수정하게 됩니다.
이건 가변조작 (mutable) 이라고 하는데요 이게 문제가 좀 많습니다.

문제점1. 사이드 이펙트가 생김 -> 만약 다른함수에서 해당 딕셔너리 참고하고 있었으면 원래 참조하던 키가 사라지니까 의도치 않게 내가 손대지 않은 쪽에서 버그가 발생할 수 있습니다.
문제점2. 걍 del 로 날려버리면 명시적이지 않은 컨디션이 됩니다. 한마디로 코드가 실행되는 시점에 dictionary에 남아있는 키가 개발자의 의도와 관계없이 몇개 빠져버릴 수 있다는겁니다. "의도치 않게 키가 빠져있다"는 상태 자체가 "딕셔너리가 내 예상과 다르게 (명시적이지 않게) 핸들링되고 있다"는 것이지여ㅑ

그래서 위 두 가지 정도의 문제점을 해결하기 위해서는 필요없는 것을 지워나가는 블랙리스팅 방식보다 필요한 것만 골라서 새로운 딕셔너리를 만드는 화이트 리스팅 방식을 사용하는게 더 좋습니다.

아래 그 예시를 하나 볼꼐요
```

# 원본에서 삭제 (무엇이 남을지 확신하기 어려움)
user_data = {"id": 1, "name": "jeff", "password": "123", "details": "..."}
del user_data["password"]
del user_data["details"]

# 필요한 것만으로 구성 (결과물이 명확함)
response_data = {
    "id": user_data["id"],
    "name": user_data["name"]
}
```

우선 키 맵핑이 뭔지 알아야 합니다.
외부 API나 디비에서 가져온 데이터의 키(key) 이름이 내 프로그램 내 내부 로직과 맞지 않는 경우가 엄청나게 많아요
del 을 쓰면 단순히 필드를 없애버리는 것이지만 매핑(mapping)을 하면 데이터를 내가 원하는대로 재구축할 수 있습니다.
예시로 db 에서 user_nm 으로 되어있는 컬럼을 내 코드에서는 user_name 으로 쓰고 싶을 때 단순히 키를 지우고 추가하는게 아니고 변환 로직을 거쳐야 한다는겁니다.
이렇게 디비와 같은 써드파티에서 가져온 원본 키를 내 프로그램 내에서 핸들링 할 때는 다른 키 값으로 변환하는 과정을 키 매핑이라고 합니다. 
jeff — 오후 5:23
dto-entity / entity - dto 패턴 (요게 핵심입니다)
딕셔너리를 (raw data) 딕셔너리인채로 놔두고 키를 뺐다 꽂았다 하는건 굉장히 불안정한 상태일 수 밖에 없습니다. (앞서말한 가변조작 가능한 상태)
그래서 데이터를 명확한 클래스(객체)로 변환해서 관리하는게 일반적입니다.
dto 와 entity 가 무엇인지 안다는 전제로 설명을 이어가 볼께요. 모르신다면 이건 따로 확인하셔야 합니다.

실무에서 이 방식을 선호할 수 밖에 없는 이유는 데이터를 dto/entity 클래스로 정의해두면 변환 과정에서 불필요한 필드는 자연스럽게 걸러버릴수 있기 때문입니다. (이걸 validating & filtering 이라고 합니다)
그래서 굳이굳이 리스크를 감수하면서 del 을 쓸 필요가 없는 겁니다.
del 을 쓰면 아래처럼 될겁니다.

```
def create_user(request_data: dict):
  del request_data['csrf_token']  # 디비에 데이터 넣기 전에 쓸모없는 필드 삭제하기 -> 이런식으로 하면 말도 안되게 귀찮아 집니다. 모든 로직에서 매번 삭제해야하니까요
  save_to_db(request_data)

```

반면 dto-entity 패턴을 쓰면 아래처럼 바뀔 수 있습니다 (보통 pydantic, dataclass 씀)

```
class CreateUserDTO(BaseModel):
  name: str
  email: str
  # 이 시점에 csrf_token 을 정의하지 않았으니까 입력데이터에 있어도 자동으로 무시(=삭제) 됨

def create_user(request_data: dict):
  user_dto = CreateUserDto(**request_data)  # 이거 가변인자 모르신다면 구글이나 ai 에게 'python *args, **kwargs 에 대해서 알려줘' 라고 요청하시면 됩니다.
  user_entity = UserEntity(name=user_dto.name, email=user_dto.email)
  save_to_db(user_entity)

```


이렇게 하면 유효성 검증 + 필터링까지 된다는 겁니다. 
이거 수업때 설명 하려다만 이유가....... 요런 이유때문입니다. 엄청 많은걸 알아야해서그래여
이 답변 내용 다 이해하시면 앞으로 배울 validating, filtering 은 끝난겁니다
꼭꼭 씹어서 소화시켜보십씨오... 굿럭....
🔥
블랙리스팅 - 기존 리스트에 값을 추가했다가 삭제하는 행동을 하는것
화이트리스팅 - 빈 도화지에 새로운 값을 계숙 추가만 하는것